This is ucblogo.info, produced by makeinfo version 4.5 from
usermanual.texi.


File: ucblogo.info,  Node: SHELL,  Prev: READCHARS,  Up: RECEIVERS

shell
-----

     SHELL command
     (SHELL command wordflag)

Under Unix, outputs the result of running `command' as a shell command.
(The command is sent to `/bin/sh', not `csh' or other alternatives.)
If the command is a literal list in the instruction line, and if you
want a backslash character sent to the shell, you must use \\ to get the
backslash through Logo's reader intact.  The output is a list containing
one member for each line generated by the shell command.  Ordinarily
each such line is represented by a list in the output, as though the
line were read using READLIST.  If a second input is given, regardless
of the value of the input, each line is represented by a word in the
output as though it were read with READWORD.  Example:

     to dayofweek
     output first first shell [date]
     end

This is "first first" to extract the first word of the first (and only)
line of the shell output.

Under DOS, SHELL is a command, not an operation; it sends its input to a
DOS command processor but does not collect the result of the command.

The Macintosh, of course, is not programmable (unless you are running
the Unix version of UCBLogo under OS X).


File: ucblogo.info,  Node: FILE ACCESS,  Next: TERMINAL ACCESS,  Prev: RECEIVERS,  Up: COMMUNICATION

File Access
===========

* Menu:

* SETPREFIX::
* PREFIX::
* OPENREAD::
* OPENWRITE::
* OPENAPPEND::
* OPENUPDATE::
* CLOSE::
* ALLOPEN::
* CLOSEALL::
* ERASEFILE::
* DRIBBLE::
* NODRIBBLE::
* SETREAD::
* SETWRITE::
* READER::
* WRITER::
* SETREADPOS::
* SETWRITEPOS::
* READPOS::
* WRITEPOS::
* EOFP::
* FILEP::


File: ucblogo.info,  Node: SETPREFIX,  Next: PREFIX,  Prev: FILE ACCESS,  Up: FILE ACCESS

setprefix
---------

     SETPREFIX string

command.  Sets a prefix that will be used as the implicit beginning of
filenames in OPENREAD, OPENWRITE, OPENAPPEND, OPENUPDATE, LOAD, and SAVE
commands.  Logo will put the appropriate separator character (slash for
Unix, backslash for DOS/Windows, colon for MacOS) between the prefix and
the filename entered by the user.  The input to SETPREFIX must be a
word, unless it is the empty list, to indicate that there should be no
prefix.

*Note OPENREAD:: , *Note OPENWRITE:: , *Note OPENAPPEND:: , *Note
OPENUPDATE:: , *Note LOAD:: , *Note SAVE:: .


File: ucblogo.info,  Node: PREFIX,  Next: OPENREAD,  Prev: SETPREFIX,  Up: FILE ACCESS

prefix
------

     PREFIX

outputs the current file prefix, or [] if there is no prefix.

*Note SETPREFIX:: .


File: ucblogo.info,  Node: OPENREAD,  Next: OPENWRITE,  Prev: PREFIX,  Up: FILE ACCESS

openread
--------

     OPENREAD filename

command.  Opens the named file for reading.  The read position is
initially at the beginning of the file.


File: ucblogo.info,  Node: OPENWRITE,  Next: OPENAPPEND,  Prev: OPENREAD,  Up: FILE ACCESS

openwrite
---------

     OPENWRITE filename

command.  Opens the named file for writing.  If the file already
existed, the old version is deleted and a new, empty file created.

OPENWRITE, but not the other OPEN variants, will accept as input a
two-element list, in which the first element must be a variable name,
and the second must be a positive integer.  A character buffer of the
specified size will be created.  When a SETWRITE is done with this same
list (in the sense of .EQ, not a copy, so you must do something like

     ? make "buf [foo 100]
     ? openwrite :buf
     ? setwrite :buf
         [...]
     ? close :buf

and not just

     ? openwrite [foo 100]
     ? setwrite [foo 100]

and so on), the printed characters are stored in the buffer; when a
CLOSE is done with the same list as input, the characters from the
buffer (treated as one long word, even if spaces and newlines are
included) become the value of the specified variable.


File: ucblogo.info,  Node: OPENAPPEND,  Next: OPENUPDATE,  Prev: OPENWRITE,  Up: FILE ACCESS

openappend
----------

     OPENAPPEND filename

command.  Opens the named file for writing.  If the file already exists,
the write position is initially set to the end of the old file, so that
newly written data will be appended to it.


File: ucblogo.info,  Node: OPENUPDATE,  Next: CLOSE,  Prev: OPENAPPEND,  Up: FILE ACCESS

openupdate
----------

     OPENUPDATE filename

command.  Opens the named file for reading and writing.  The read and
write position is initially set to the end of the old file, if any.
Note: each open file has only one position, for both reading and
writing.  If a file opened for update is both READER and WRITER at the
same time, then SETREADPOS will also affect WRITEPOS and vice versa.
Also, if you alternate reading and writing the same file, you must
SETREADPOS between a write and a read, and SETWRITEPOS between a read
and a write.

*Note READER:: , *Note WRITER:: , *Note SETREADPOS:: , *Note
SETWRITEPOS::


File: ucblogo.info,  Node: CLOSE,  Next: ALLOPEN,  Prev: OPENUPDATE,  Up: FILE ACCESS

close
-----

     CLOSE filename

command.  Closes the named file.  If the file was currently the reader
or writer, then the reader or writer is changed to the keyboard or
screen, as if SETREAD [] or SETWRITE [] had been done.


File: ucblogo.info,  Node: ALLOPEN,  Next: CLOSEALL,  Prev: CLOSE,  Up: FILE ACCESS

allopen
-------

     ALLOPEN

outputs a list whose members are the names of all files currently open.
This list does not include the dribble file, if any.


File: ucblogo.info,  Node: CLOSEALL,  Next: ERASEFILE,  Prev: ALLOPEN,  Up: FILE ACCESS

closeall
--------

     CLOSEALL					(library procedure)

command.  Closes all open files.  Abbreviates FOREACH ALLOPEN [CLOSE ?]

*Note FOREACH:: , *Note CLOSE::


File: ucblogo.info,  Node: ERASEFILE,  Next: DRIBBLE,  Prev: CLOSEALL,  Up: FILE ACCESS

erasefile
---------

     ERASEFILE filename
     ERF filename

command.  Erases (deletes, removes) the named file, which should not
currently be open.


File: ucblogo.info,  Node: DRIBBLE,  Next: NODRIBBLE,  Prev: ERASEFILE,  Up: FILE ACCESS

dribble
-------

     DRIBBLE filename

command.  Creates a new file whose name is the input, like OPENWRITE,
and begins recording in that file everything that is read from the
keyboard or written to the terminal.  That is, this writing is in
addition to the writing to WRITER.  The intent is to create a transcript
of a Logo session, including things like prompt characters and
interactions.

*Note OPENWRITE:: , *Note WRITER::


File: ucblogo.info,  Node: NODRIBBLE,  Next: SETREAD,  Prev: DRIBBLE,  Up: FILE ACCESS

nodribble
---------

     NODRIBBLE

command.  Stops copying information into the dribble file, and closes
the file.


File: ucblogo.info,  Node: SETREAD,  Next: SETWRITE,  Prev: NODRIBBLE,  Up: FILE ACCESS

setread
-------

     SETREAD filename

command.  Makes the named file the read stream, used for READLIST, etc.
The file must already be open with OPENREAD or OPENUPDATE.  If the input
is the empty list, then the read stream becomes the terminal, as usual.
Changing the read stream does not close the file that was previously the
read stream, so it is possible to alternate between files.

*Note READLIST:: , *Note OPENREAD:: , *Note OPENUPDATE::


File: ucblogo.info,  Node: SETWRITE,  Next: READER,  Prev: SETREAD,  Up: FILE ACCESS

setwrite
--------

     SETWRITE filename

command.  Makes the named file the write stream, used for PRINT, etc.
The file must already be open with OPENWRITE, OPENAPPEND, or
OPENUPDATE.  If the input is the empty list, then the write stream
becomes the terminal, as usual.  Changing the write stream does not
close the file that was previously the write stream, so it is possible
to alternate between files.

If the input is a list, then its first element must be a variable name,
and its second and last element must be a positive integer; a buffer of
that many characters will be allocated, and will become the
writestream.  If the same list (same in the .EQ sense, not a copy) has
been used as input to OPENWRITE, then the already-allocated buffer will
be used, and the writer can be changed to and from this buffer, with
all the characters accumulated as in a file.  When the same list is
used as input to CLOSE, the contents of the buffer (as an unparsed
word, which may contain newline characters) will become the value of
the named variable.  For compatibility with earlier versions, if the
list has not been opened when the SETWRITE is done, it will be opened
implicitly, but the first SETWRITE after this one will implicitly close
it, setting the variable and freeing the allocated buffer.

*Note PRINT:: , *Note OPENWRITE:: ; *Note OPENAPPEND:: ; *Note
OPENUPDATE::


File: ucblogo.info,  Node: READER,  Next: WRITER,  Prev: SETWRITE,  Up: FILE ACCESS

reader
------

     READER

outputs the name of the current read stream file, or the empty list if
the read stream is the terminal.


File: ucblogo.info,  Node: WRITER,  Next: SETREADPOS,  Prev: READER,  Up: FILE ACCESS

writer
------

     WRITER

outputs the name of the current write stream file, or the empty list if
the write stream is the terminal.


File: ucblogo.info,  Node: SETREADPOS,  Next: SETWRITEPOS,  Prev: WRITER,  Up: FILE ACCESS

setreadpos
----------

     SETREADPOS charpos

command.  Sets the file pointer of the read stream file so that the next
READLIST, etc., will begin reading at the `charpos'th character in the
file, counting from 0.  (That is, SETREADPOS 0 will start reading from
the beginning of the file.)  Meaningless if the read stream is the
terminal.

*Note READLIST:: .


File: ucblogo.info,  Node: SETWRITEPOS,  Next: READPOS,  Prev: SETREADPOS,  Up: FILE ACCESS

setwritepos
-----------

     SETWRITEPOS charpos

command.  Sets the file pointer of the write stream file so that the
next PRINT, etc., will begin writing at the `charpos'th character in the
file, counting from 0.  (That is, SETWRITEPOS 0 will start writing from
the beginning of the file.)  Meaningless if the write stream is the
terminal.

*Note PRINT:: .


File: ucblogo.info,  Node: READPOS,  Next: WRITEPOS,  Prev: SETWRITEPOS,  Up: FILE ACCESS

readpos
-------

     READPOS

outputs the file position of the current read stream file.


File: ucblogo.info,  Node: WRITEPOS,  Next: EOFP,  Prev: READPOS,  Up: FILE ACCESS

writepos
--------

     WRITEPOS

outputs the file position of the current write stream file.


File: ucblogo.info,  Node: EOFP,  Next: FILEP,  Prev: WRITEPOS,  Up: FILE ACCESS

eofp
----

     EOFP
     EOF?

predicate, outputs TRUE if there are no more characters to be read in
the read stream file, FALSE otherwise.


File: ucblogo.info,  Node: FILEP,  Prev: EOFP,  Up: FILE ACCESS

filep
-----

     FILEP filename
     FILE? filename					(library procedure)

predicate, outputs TRUE if a file of the specified name exists and can
be read, FALSE otherwise.


File: ucblogo.info,  Node: TERMINAL ACCESS,  Prev: FILE ACCESS,  Up: COMMUNICATION

Terminal Access
===============

* Menu:

* KEYP::
* CLEARTEXT::
* SETCURSOR::
* CURSOR::
* SETMARGINS::
* SETTEXTCOLOR::


File: ucblogo.info,  Node: KEYP,  Next: CLEARTEXT,  Prev: TERMINAL ACCESS,  Up: TERMINAL ACCESS

keyp
----

     KEYP
     KEY?

predicate, outputs TRUE if there are characters waiting to be read from
the read stream.  If the read stream is a file, this is equivalent to
NOT EOFP.  If the read stream is the terminal, then echoing is turned
off and the terminal is set to CBREAK (character at a time instead of
line at a time) mode.  It remains in this mode until some line-mode
reading is requested (e.g., READLIST).  The Unix operating system
forgets about any pending characters when it switches modes, so the
first KEYP invocation will always output FALSE.

*Note EOFP:: , *Note READLIST::


File: ucblogo.info,  Node: CLEARTEXT,  Next: SETCURSOR,  Prev: KEYP,  Up: TERMINAL ACCESS

cleartext
---------

     CLEARTEXT
     CT

command.  Clears the text screen of the terminal.


File: ucblogo.info,  Node: SETCURSOR,  Next: CURSOR,  Prev: CLEARTEXT,  Up: TERMINAL ACCESS

setcursor
---------

     SETCURSOR vector

command.  The input is a list of two numbers, the x and y coordinates of
a screen position (origin in the upper left corner, positive direction
is southeast).  The screen cursor is moved to the requested position.
This command also forces the immediate printing of any buffered
characters.


File: ucblogo.info,  Node: CURSOR,  Next: SETMARGINS,  Prev: SETCURSOR,  Up: TERMINAL ACCESS

cursor
------

     CURSOR

outputs a list containing the current x and y coordinates of the screen
cursor.  Logo may get confused about the current cursor position if,
e.g., you type in a long line that wraps around or your program prints
escape codes that affect the terminal strangely.


File: ucblogo.info,  Node: SETMARGINS,  Next: SETTEXTCOLOR,  Prev: CURSOR,  Up: TERMINAL ACCESS

setmargins
----------

     SETMARGINS vector

command.  The input must be a list of two numbers, as for SETCURSOR.
The effect is to clear the screen and then arrange for all further
printing to be shifted down and to the right according to the indicated
margins.  Specifically, every time a newline character is printed
(explicitly or implicitly) Logo will type x_margin spaces, and on every
invocation of SETCURSOR the margins will be added to the input x and y
coordinates.  (CURSOR will report the cursor position relative to the
margins, so that this shift will be invisible to Logo programs.)  The
purpose of this command is to accommodate the display of terminal
screens in lecture halls with inadequate TV monitors that miss the top
and left edges of the screen.

*Note SETCURSOR:: .


File: ucblogo.info,  Node: SETTEXTCOLOR,  Prev: SETMARGINS,  Up: TERMINAL ACCESS

settextcolor
------------

     SETTEXTCOLOR foreground background
     SETTC foreground background

Command (Windows and DOS extended only).  The inputs are color numbers,
as for turtle graphics.  Future printing to the text window will use the
specified colors for foreground (the characters printed) and background
(the space under those characters).  Using STANDOUT will revert to the
default text window colors.  In the DOS extended (ucblogo.exe) version,
colors in textscreen mode are limited to numbers 0-7, and the coloring
applies only to text printed by the program, not to the echoing of text
typed by the user.  Neither limitation applies to the text portion of
splitscreen mode, which is actually drawn as graphics internally.

*Note STANDOUT:: .


File: ucblogo.info,  Node: ARITHMETIC,  Next: LOGICAL OPERATIONS,  Prev: COMMUNICATION,  Up: Top

Arithmetic
**********

* Menu:

* NUMERIC OPERATIONS::
* NUMERIC PREDICATES::
* RANDOM NUMBERS::
* PRINT FORMATTING::
* BITWISE OPERATIONS::


File: ucblogo.info,  Node: NUMERIC OPERATIONS,  Next: NUMERIC PREDICATES,  Prev: ARITHMETIC,  Up: ARITHMETIC

Numeric Operations
==================

* Menu:

* SUM::
* DIFFERENCE::
* MINUS::
* PRODUCT::
* QUOTIENT::
* REMAINDER::
* MODULO::
* INT::
* ROUND::
* SQRT::
* POWER::
* EXP::
* LOG10::
* LN::
* SIN::
* RADSIN::
* COS::
* RADCOS::
* ARCTAN::
* RADARCTAN::
* ISEQ::
* RSEQ::


File: ucblogo.info,  Node: SUM,  Next: DIFFERENCE,  Prev: NUMERIC OPERATIONS,  Up: NUMERIC OPERATIONS

sum
---

     SUM num1 num2
     (SUM num1 num2 num3 ...)
     num1 + num2

outputs the sum of its inputs.


File: ucblogo.info,  Node: DIFFERENCE,  Next: MINUS,  Prev: SUM,  Up: NUMERIC OPERATIONS

difference
----------

     DIFFERENCE num1 num2
     num1 - num2

outputs the difference of its inputs.  Minus sign means infix difference
in ambiguous contexts (when preceded by a complete expression), unless
it is preceded by a space and followed by a nonspace.  (See also MINUS.)


File: ucblogo.info,  Node: MINUS,  Next: PRODUCT,  Prev: DIFFERENCE,  Up: NUMERIC OPERATIONS

minus
-----

     MINUS num
     - num

outputs the negative of its input.  Minus sign means unary minus if the
previous token is an infix operator or open parenthesis, or it is
preceded by a space and followed by a nonspace.  There is a difference
in binding strength between the two forms:

     MINUS 3 + 4     means   -(3+4)
     - 3 + 4         means   (-3)+4


File: ucblogo.info,  Node: PRODUCT,  Next: QUOTIENT,  Prev: MINUS,  Up: NUMERIC OPERATIONS

product
-------

     PRODUCT num1 num2
     (PRODUCT num1 num2 num3 ...)
     num1 * num2

outputs the product of its inputs.


File: ucblogo.info,  Node: QUOTIENT,  Next: REMAINDER,  Prev: PRODUCT,  Up: NUMERIC OPERATIONS

quotient
--------

     QUOTIENT num1 num2
     (QUOTIENT num)
     num1 / num2

outputs the quotient of its inputs.  The quotient of two integers is an
integer if and only if the dividend is a multiple of the divisor.  (In
other words, QUOTIENT 5 2 is 2.5, not 2, but QUOTIENT 4 2 is 2, not 2.0
-- it does the right thing.)  With a single input, QUOTIENT outputs the
reciprocal of the input.


File: ucblogo.info,  Node: REMAINDER,  Next: MODULO,  Prev: QUOTIENT,  Up: NUMERIC OPERATIONS

remainder
---------

     REMAINDER num1 num2

outputs the remainder on dividing `num1' by `num2'; both must be
integers and the result is an integer with the same sign as num1.


File: ucblogo.info,  Node: MODULO,  Next: INT,  Prev: REMAINDER,  Up: NUMERIC OPERATIONS

modulo
------

     MODULO num1 num2

outputs the remainder on dividing `num1' by `num2'; both must be
integers and the result is an integer with the same sign as num2.


File: ucblogo.info,  Node: INT,  Next: ROUND,  Prev: MODULO,  Up: NUMERIC OPERATIONS

int
---

     INT num

outputs its input with fractional part removed, i.e., an integer with
the same sign as the input, whose absolute value is the largest integer
less than or equal to the absolute value of the input.


File: ucblogo.info,  Node: ROUND,  Next: SQRT,  Prev: INT,  Up: NUMERIC OPERATIONS

round
-----

     ROUND num

outputs the nearest integer to the input.


File: ucblogo.info,  Node: SQRT,  Next: POWER,  Prev: ROUND,  Up: NUMERIC OPERATIONS

sqrt
----

     SQRT num

outputs the square root of the input, which must be nonnegative.


File: ucblogo.info,  Node: POWER,  Next: EXP,  Prev: SQRT,  Up: NUMERIC OPERATIONS

power
-----

     POWER num1 num2

outputs `num1' to the `num2' power.  If num1 is negative, then num2
must be an integer.


File: ucblogo.info,  Node: EXP,  Next: LOG10,  Prev: POWER,  Up: NUMERIC OPERATIONS

exp
---

     EXP num

outputs e (2.718281828+) to the input power.


File: ucblogo.info,  Node: LOG10,  Next: LN,  Prev: EXP,  Up: NUMERIC OPERATIONS

log10
-----

     LOG10 num

outputs the common logarithm of the input.


File: ucblogo.info,  Node: LN,  Next: SIN,  Prev: LOG10,  Up: NUMERIC OPERATIONS

ln
--

     LN num

outputs the natural logarithm of the input.


File: ucblogo.info,  Node: SIN,  Next: RADSIN,  Prev: LN,  Up: NUMERIC OPERATIONS

sin
---

     SIN degrees

outputs the sine of its input, which is taken in degrees.


File: ucblogo.info,  Node: RADSIN,  Next: COS,  Prev: SIN,  Up: NUMERIC OPERATIONS

radsin
------

     RADSIN radians

outputs the sine of its input, which is taken in radians.


File: ucblogo.info,  Node: COS,  Next: RADCOS,  Prev: RADSIN,  Up: NUMERIC OPERATIONS

cos
---

     COS degrees

outputs the cosine of its input, which is taken in degrees.


File: ucblogo.info,  Node: RADCOS,  Next: ARCTAN,  Prev: COS,  Up: NUMERIC OPERATIONS

radcos
------

     RADCOS radians

outputs the cosine of its input, which is taken in radians.


File: ucblogo.info,  Node: ARCTAN,  Next: RADARCTAN,  Prev: RADCOS,  Up: NUMERIC OPERATIONS

arctan
------

     ARCTAN num
     (ARCTAN x y)

outputs the arctangent, in degrees, of its input.  With two inputs,
outputs the arctangent of y/x, if x is nonzero, or 90 or -90 depending
on the sign of y, if x is zero.


File: ucblogo.info,  Node: RADARCTAN,  Next: ISEQ,  Prev: ARCTAN,  Up: NUMERIC OPERATIONS

radarctan
---------

     RADARCTAN num
     (RADARCTAN x y)

outputs the arctangent, in radians, of its input.  With two inputs,
outputs the arctangent of y/x, if x is nonzero, or pi/2 or -pi/2
depending on the sign of y, if x is zero.

The expression 2*(RADARCTAN 0 1) can be used to get the value of pi.


File: ucblogo.info,  Node: ISEQ,  Next: RSEQ,  Prev: RADARCTAN,  Up: NUMERIC OPERATIONS

iseq
----

     ISEQ from to					(library procedure)

outputs a list of the integers from FROM to TO, inclusive.

     ? show iseq 3 7
     [3 4 5 6 7]
     ? show iseq 7 3
     [7 6 5 4 3]


File: ucblogo.info,  Node: RSEQ,  Prev: ISEQ,  Up: NUMERIC OPERATIONS

rseq
----

     RSEQ from to count				(library procedure)

outputs a list of COUNT equally spaced rational numbers between FROM and
TO, inclusive.

     ? show rseq 3 5 9
     [3 3.25 3.5 3.75 4 4.25 4.5 4.75 5]
     ? show rseq 3 5 5
     [3 3.5 4 4.5 5]


File: ucblogo.info,  Node: NUMERIC PREDICATES,  Next: RANDOM NUMBERS,  Prev: NUMERIC OPERATIONS,  Up: ARITHMETIC

Numeric Predicates
==================

* Menu:

* LESSP::
* GREATERP::
* LESSEQUALP::
* GREATEREQUALP::


File: ucblogo.info,  Node: LESSP,  Next: GREATERP,  Prev: NUMERIC PREDICATES,  Up: NUMERIC PREDICATES

lessp
-----

     LESSP num1 num2
     LESS? num1 num2
     num1 < num2

outputs TRUE if its first input is strictly less than its second.


File: ucblogo.info,  Node: GREATERP,  Next: LESSEQUALP,  Prev: LESSP,  Up: NUMERIC PREDICATES

greaterp
--------

     GREATERP num1 num2
     GREATER? num1 num2
     num1 > num2

outputs TRUE if its first input is strictly greater than its second.


File: ucblogo.info,  Node: LESSEQUALP,  Next: GREATEREQUALP,  Prev: GREATERP,  Up: NUMERIC PREDICATES

lessequalp
----------

     LESSEQUALP num1 num2
     LESSEQUAL? num1 num2
     num1 <= num2

outputs TRUE if its first input is less than or equal to its second.


File: ucblogo.info,  Node: GREATEREQUALP,  Prev: LESSEQUALP,  Up: NUMERIC PREDICATES

greaterequalp
-------------

     GREATEREQUALP num1 num2
     GREATEREQUAL? num1 num2
     num1 >= num2

outputs TRUE if its first input is greater than or equal to its second.


File: ucblogo.info,  Node: RANDOM NUMBERS,  Next: PRINT FORMATTING,  Prev: NUMERIC PREDICATES,  Up: ARITHMETIC

Random Numbers
==============

* Menu:

* RANDOM::
* RERANDOM::


File: ucblogo.info,  Node: RANDOM,  Next: RERANDOM,  Prev: RANDOM NUMBERS,  Up: RANDOM NUMBERS

random
------

     RANDOM num
     (RANDOM start end)

with one input, outputs a random nonnegative integer less than its
input, which must be a positive integer.

With two inputs, RANDOM outputs a random integer greater than or equal
to the first input, and less than or equal to the second input.  Both
inputs must be integers, and the first must be less than the second.
(RANDOM 0 9) is equivalent to RANDOM 10; (RANDOM 3 8) is equivalent to
(RANDOM 6)+3.


File: ucblogo.info,  Node: RERANDOM,  Prev: RANDOM,  Up: RANDOM NUMBERS

rerandom
--------

     RERANDOM
     (RERANDOM seed)

command.  Makes the results of RANDOM reproducible.  Ordinarily the
sequence of random numbers is different each time Logo is used.  If you
need the same sequence of pseudo-random numbers repeatedly, e.g. to
debug a program, say RERANDOM before the first invocation of RANDOM.  If
you need more than one repeatable sequence, you can give RERANDOM an
integer input; each possible input selects a unique sequence of numbers.


File: ucblogo.info,  Node: PRINT FORMATTING,  Next: BITWISE OPERATIONS,  Prev: RANDOM NUMBERS,  Up: ARITHMETIC

Print Formatting
================

* Menu:

* FORM::


File: ucblogo.info,  Node: FORM,  Prev: PRINT FORMATTING,  Up: PRINT FORMATTING

form
----

     FORM num width precision

outputs a word containing a printable representation of `num', possibly
preceded by spaces (and therefore not a number for purposes of
performing arithmetic operations), with at least `width' characters,
including exactly `precision' digits after the decimal point.  (If
`precision' is 0 then there will be no decimal point in the output.)

As a debugging feature, (FORM num -1 format) will print the floating
point `num' according to the C printf `format', to allow

     to hex :num
     op form :num -1 "|%08X %08X|
     end

to allow finding out the exact result of floating point operations.  The
precise format needed may be machine-dependent.


File: ucblogo.info,  Node: BITWISE OPERATIONS,  Prev: PRINT FORMATTING,  Up: ARITHMETIC

Bitwise Operations
==================

* Menu:

* BITAND::
* BITOR::
* BITXOR::
* BITNOT::
* ASHIFT::
* LSHIFT::


File: ucblogo.info,  Node: BITAND,  Next: BITOR,  Prev: BITWISE OPERATIONS,  Up: BITWISE OPERATIONS

bitand
------

     BITAND num1 num2
     (BITAND num1 num2 num3 ...)

outputs the bitwise AND of its inputs, which must be integers.

*Note AND:: .


File: ucblogo.info,  Node: BITOR,  Next: BITXOR,  Prev: BITAND,  Up: BITWISE OPERATIONS

bitor
-----

     BITOR num1 num2
     (BITOR num1 num2 num3 ...)

outputs the bitwise OR of its inputs, which must be integers.

*Note OR:: .


File: ucblogo.info,  Node: BITXOR,  Next: BITNOT,  Prev: BITOR,  Up: BITWISE OPERATIONS

bitxor
------

     BITXOR num1 num2
     (BITXOR num1 num2 num3 ...)

outputs the bitwise EXCLUSIVE OR of its inputs, which must be integers.

*Note OR:: .


File: ucblogo.info,  Node: BITNOT,  Next: ASHIFT,  Prev: BITXOR,  Up: BITWISE OPERATIONS

bitnot
------

     BITNOT num

outputs the bitwise NOT of its input, which must be an integer.

*Note NOT:: .


File: ucblogo.info,  Node: ASHIFT,  Next: LSHIFT,  Prev: BITNOT,  Up: BITWISE OPERATIONS

ashift
------

     ASHIFT num1 num2

outputs `num1' arithmetic-shifted to the left by `num2' bits.  If num2
is negative, the shift is to the right with sign extension.  The inputs
must be integers.


File: ucblogo.info,  Node: LSHIFT,  Prev: ASHIFT,  Up: BITWISE OPERATIONS

lshift
------

     LSHIFT num1 num2

outputs `num1' logical-shifted to the left by `num2' bits.  If num2 is
negative, the shift is to the right with zero fill.  The inputs must be
integers.


File: ucblogo.info,  Node: LOGICAL OPERATIONS,  Next: GRAPHICS,  Prev: ARITHMETIC,  Up: Top

Logical Operations
******************

* Menu:

* AND::
* OR::
* NOT::


File: ucblogo.info,  Node: AND,  Next: OR,  Prev: LOGICAL OPERATIONS,  Up: LOGICAL OPERATIONS

and
---

     AND tf1 tf2
     (AND tf1 tf2 tf3 ...)

outputs TRUE if all inputs are TRUE, otherwise FALSE.  All inputs must
be TRUE or FALSE.  (Comparison is case-insensitive regardless of the
value of CASEIGNOREDP.  That is, `true' or `True' or `TRUE' are all the
same.)  An input can be a list, in which case it is taken as an
expression to run; that expression must produce a TRUE or FALSE value.
List expressions are evaluated from left to right; as soon as a FALSE
value is found, the remaining inputs are not examined.  Example:

     MAKE "RESULT AND [NOT (:X = 0)] [(1 / :X) > .5]

to avoid the division by zero if the first part is false.

*Note CASEIGNOREDP:: .


File: ucblogo.info,  Node: OR,  Next: NOT,  Prev: AND,  Up: LOGICAL OPERATIONS

or
--

     OR tf1 tf2
     (OR tf1 tf2 tf3 ...)

outputs TRUE if any input is TRUE, otherwise FALSE.  All inputs must be
TRUE or FALSE.  (Comparison is case-insensitive regardless of the value
of CASEIGNOREDP.  That is, `true' or `True' or `TRUE' are all the
same.)  An input can be a list, in which case it is taken as an
expression to run; that expression must produce a TRUE or FALSE value.
List expressions are evaluated from left to right; as soon as a TRUE
value is found, the remaining inputs are not examined.  Example:

     IF OR :X=0 [some.long.computation] [...]

to avoid the long computation if the first condition is met.

*Note CASEIGNOREDP:: .


File: ucblogo.info,  Node: NOT,  Prev: OR,  Up: LOGICAL OPERATIONS

not
---

     NOT tf

outputs TRUE if the input is FALSE, and vice versa.  The input can be a
list, in which case it is taken as an expression to run; that
expression must produce a TRUE or FALSE value.


File: ucblogo.info,  Node: GRAPHICS,  Next: WORKSPACE MANAGEMENT,  Prev: LOGICAL OPERATIONS,  Up: Top

Graphics
********

Berkeley Logo provides traditional Logo turtle graphics with one turtle.
Multiple turtles, dynamic turtles, and collision detection are not
supported.  This is the most hardware-dependent part of Logo; some
features may exist on some machines but not others.  Nevertheless, the
goal has been to make Logo programs as portable as possible, rather
than to take fullest advantage of the capabilities of each machine.  In
particular, Logo attempts to scale the screen so that turtle
coordinates [-100 -100] and [100 100] fit on the graphics window, and
so that the aspect ratio is 1:1.

The center of the graphics window (which may or may not be the entire
screen, depending on the machine used) is turtle location [0 0].
Positive X is to the right; positive Y is up.  Headings (angles) are
measured in degrees clockwise from the positive Y axis.  (This differs
from the common mathematical convention of measuring angles
counterclockwise from the positive X axis.)  The turtle is represented
as an isoceles triangle; the actual turtle position is at the midpoint
of the base (the short side).  However, the turtle is drawn one step
behind its actual position, so that the display of the base of the
turtle's triangle does not obscure a line drawn perpendicular to it (as
would happen after drawing a square).

Colors are, of course, hardware-dependent.  However, Logo provides
partial hardware independence by interpreting color numbers 0 through 7
uniformly on all computers:

     	0  black        1  blue         2  green        3  cyan
     	4  red          5  magenta      6  yellow       7 white

Where possible, Logo provides additional user-settable colors; how many
are available depends on the hardware and operating system environment.
If at least 16 colors are available, Logo tries to provide uniform
initial settings for the colors 8-15:

     	 8  brown        9  tan         10  forest      11  aqua
     	12  salmon      13  purple      14  orange      15  grey

Logo begins with a black background and white pen.

* Menu:

* TURTLE MOTION::
* TURTLE MOTION QUERIES::
* TURTLE AND WINDOW CONTROL::
* TURTLE AND WINDOW QUERIES::
* PEN AND BACKGROUND CONTROL::
* PEN QUERIES::
* SAVING AND LOADING PICTURES::
* MOUSE QUERIES::


File: ucblogo.info,  Node: TURTLE MOTION,  Next: TURTLE MOTION QUERIES,  Prev: GRAPHICS,  Up: GRAPHICS

Turtle Motion
=============

* Menu:

* FORWARD::
* BACK::
* LEFT::
* RIGHT::
* SETPOS::
* SETXY::
* SETX::
* SETY::
* SETHEADING::
* HOME::
* ARC::


File: ucblogo.info,  Node: FORWARD,  Next: BACK,  Prev: TURTLE MOTION,  Up: TURTLE MOTION

forward
-------

     FORWARD dist
     FD dist

moves the turtle forward, in the direction that it's facing, by the
specified distance (measured in turtle steps).


File: ucblogo.info,  Node: BACK,  Next: LEFT,  Prev: FORWARD,  Up: TURTLE MOTION

back
----

     BACK dist
     BK dist

moves the turtle backward, i.e., exactly opposite to the direction that
it's facing, by the specified distance.  (The heading of the turtle does
not change.)


File: ucblogo.info,  Node: LEFT,  Next: RIGHT,  Prev: BACK,  Up: TURTLE MOTION

left
----

     LEFT degrees
     LT degrees

turns the turtle counterclockwise by the specified angle, measured in
degrees (1/360 of a circle).


File: ucblogo.info,  Node: RIGHT,  Next: SETPOS,  Prev: LEFT,  Up: TURTLE MOTION

right
-----

     RIGHT degrees
     RT degrees

turns the turtle clockwise by the specified angle, measured in degrees
(1/360 of a circle).


File: ucblogo.info,  Node: SETPOS,  Next: SETXY,  Prev: RIGHT,  Up: TURTLE MOTION

setpos
------

     SETPOS pos

moves the turtle to an absolute screen position.  The input is a list
of two numbers, the X and Y coordinates.


File: ucblogo.info,  Node: SETXY,  Next: SETX,  Prev: SETPOS,  Up: TURTLE MOTION

setxy
-----

     SETXY xcor ycor

moves the turtle to an absolute screen position.  The two inputs are
numbers, the X and Y coordinates.


File: ucblogo.info,  Node: SETX,  Next: SETY,  Prev: SETXY,  Up: TURTLE MOTION

setx
----

     SETX xcor

moves the turtle horizontally from its old position to a new absolute
horizontal coordinate.  The input is the new X coordinate.


File: ucblogo.info,  Node: SETY,  Next: SETHEADING,  Prev: SETX,  Up: TURTLE MOTION

sety
----

     SETY ycor

moves the turtle vertically from its old position to a new absolute
vertical coordinate.  The input is the new Y coordinate.


File: ucblogo.info,  Node: SETHEADING,  Next: HOME,  Prev: SETY,  Up: TURTLE MOTION

setheading
----------

     SETHEADING degrees
     SETH degrees

turns the turtle to a new absolute heading.  The input is a number, the
heading in degrees clockwise from the positive Y axis.


File: ucblogo.info,  Node: HOME,  Next: ARC,  Prev: SETHEADING,  Up: TURTLE MOTION

home
----

     HOME

moves the turtle to the center of the screen.  Equivalent to
SETPOS [0 0] SETHEADING 0.

*Note SETPOS:: , *Note SETHEADING:: .


File: ucblogo.info,  Node: ARC,  Prev: HOME,  Up: TURTLE MOTION

arc
---

     ARC angle radius

draws an arc of a circle, with the turtle at the center, with the
specified radius, starting at the turtle's heading and extending
clockwise through the specified angle.  The turtle does not move.


File: ucblogo.info,  Node: TURTLE MOTION QUERIES,  Next: TURTLE AND WINDOW CONTROL,  Prev: TURTLE MOTION,  Up: GRAPHICS

Turtle Motion Queries
=====================

* Menu:

* POS::
* XCOR::
* YCOR::
* HEADING::
* TOWARDS::
* SCRUNCH::


File: ucblogo.info,  Node: POS,  Next: XCOR,  Prev: TURTLE MOTION QUERIES,  Up: TURTLE MOTION QUERIES

pos
---

     POS

outputs the turtle's current position, as a list of two numbers, the X
and Y coordinates.


File: ucblogo.info,  Node: XCOR,  Next: YCOR,  Prev: POS,  Up: TURTLE MOTION QUERIES

xcor
----

     XCOR						(library procedure)

outputs a number, the turtle's X coordinate.


File: ucblogo.info,  Node: YCOR,  Next: HEADING,  Prev: XCOR,  Up: TURTLE MOTION QUERIES

ycor
----

     YCOR						(library procedure)

outputs a number, the turtle's Y coordinate.


File: ucblogo.info,  Node: HEADING,  Next: TOWARDS,  Prev: YCOR,  Up: TURTLE MOTION QUERIES

heading
-------

     HEADING

outputs a number, the turtle's heading in degrees.


File: ucblogo.info,  Node: TOWARDS,  Next: SCRUNCH,  Prev: HEADING,  Up: TURTLE MOTION QUERIES

towards
-------

     TOWARDS pos

outputs a number, the heading at which the turtle should be facing so
that it would point from its current position to the position given as
the input.


File: ucblogo.info,  Node: SCRUNCH,  Prev: TOWARDS,  Up: TURTLE MOTION QUERIES

scrunch
-------

     SCRUNCH

outputs a list containing two numbers, the X and Y scrunch factors, as
used by SETSCRUNCH.  (But note that SETSCRUNCH takes two numbers as
inputs, not one list of numbers.)

*Note SETSCRUNCH:: .


File: ucblogo.info,  Node: TURTLE AND WINDOW CONTROL,  Next: TURTLE AND WINDOW QUERIES,  Prev: TURTLE MOTION QUERIES,  Up: GRAPHICS

Turtle and Window Control
=========================

* Menu:

* SHOWTURTLE::
* HIDETURTLE::
* CLEAN::
* CLEARSCREEN::
* WRAP::
* WINDOW::
* FENCE::
* FILL::
* LABEL::
* TEXTSCREEN::
* FULLSCREEN::
* SPLITSCREEN::
* SETSCRUNCH::
* REFRESH::
* NOREFRESH::


File: ucblogo.info,  Node: SHOWTURTLE,  Next: HIDETURTLE,  Prev: TURTLE AND WINDOW CONTROL,  Up: TURTLE AND WINDOW CONTROL

showturtle
----------

     SHOWTURTLE
     ST

makes the turtle visible.


File: ucblogo.info,  Node: HIDETURTLE,  Next: CLEAN,  Prev: SHOWTURTLE,  Up: TURTLE AND WINDOW CONTROL

hideturtle
----------

     HIDETURTLE
     HT

makes the turtle invisible.  It's a good idea to do this while you're in
the middle of a complicated drawing, because hiding the turtle speeds up
the drawing substantially.


File: ucblogo.info,  Node: CLEAN,  Next: CLEARSCREEN,  Prev: HIDETURTLE,  Up: TURTLE AND WINDOW CONTROL

clean
-----

     CLEAN

erases all lines that the turtle has drawn on the graphics window.  The
turtle's state (position, heading, pen mode, etc.) is not changed.


File: ucblogo.info,  Node: CLEARSCREEN,  Next: WRAP,  Prev: CLEAN,  Up: TURTLE AND WINDOW CONTROL

clearscreen
-----------

     CLEARSCREEN
     CS

erases the graphics window and sends the turtle to its initial position
and heading.  Like HOME and CLEAN together.

*Note HOME:: .


File: ucblogo.info,  Node: WRAP,  Next: WINDOW,  Prev: CLEARSCREEN,  Up: TURTLE AND WINDOW CONTROL

wrap
----

     WRAP

tells the turtle to enter wrap mode:  From now on, if the turtle is
asked to move past the boundary of the graphics window, it will "wrap
around" and reappear at the opposite edge of the window.  The top edge
wraps to the bottom edge, while the left edge wraps to the right edge.
(So the window is topologically equivalent to a torus.)  This is the
turtle's initial mode.  Compare WINDOW and FENCE.

*Note FENCE:: .


File: ucblogo.info,  Node: WINDOW,  Next: FENCE,  Prev: WRAP,  Up: TURTLE AND WINDOW CONTROL

window
------

     WINDOW

tells the turtle to enter window mode:  From now on, if the turtle is
asked to move past the boundary of the graphics window, it will move
offscreen.  The visible graphics window is considered as just part of an
infinite graphics plane; the turtle can be anywhere on the plane.  (If
you lose the turtle, HOME will bring it back to the center of the
window.)  Compare WRAP and FENCE.

*Note HOME:: .


File: ucblogo.info,  Node: FENCE,  Next: FILL,  Prev: WINDOW,  Up: TURTLE AND WINDOW CONTROL

fence
-----

     FENCE

tells the turtle to enter fence mode:  From now on, if the turtle is
asked to move past the boundary of the graphics window, it will move as
far as it can and then stop at the edge with an "out of bounds" error
message.  Compare WRAP and WINDOW.

*Note WRAP:: .


File: ucblogo.info,  Node: FILL,  Next: LABEL,  Prev: FENCE,  Up: TURTLE AND WINDOW CONTROL

fill
----

     FILL

fills in a region of the graphics window containing the turtle and
bounded by lines that have been drawn earlier.  This is not portable; it
doesn't work for all machines, and may not work exactly the same way on
different machines.


File: ucblogo.info,  Node: LABEL,  Next: TEXTSCREEN,  Prev: FILL,  Up: TURTLE AND WINDOW CONTROL

label
-----

     LABEL text

takes a word or list as input, and prints the input on the graphics
window, starting at the turtle's position.


File: ucblogo.info,  Node: TEXTSCREEN,  Next: FULLSCREEN,  Prev: LABEL,  Up: TURTLE AND WINDOW CONTROL

textscreen
----------

     TEXTSCREEN
     TS

rearranges the size and position of windows to maximize the space
available in the text window (the window used for interaction with
Logo).  The details differ among machines.  Compare SPLITSCREEN and
FULLSCREEN.

*Note SPLITSCREEN:: .


File: ucblogo.info,  Node: FULLSCREEN,  Next: SPLITSCREEN,  Prev: TEXTSCREEN,  Up: TURTLE AND WINDOW CONTROL

fullscreen
----------

     FULLSCREEN
     FS

rearranges the size and position of windows to maximize the space
available in the graphics window.  The details differ among machines.
Compare SPLITSCREEN and TEXTSCREEN.

In the DOS version, switching from fullscreen to splitscreen loses the
part of the picture that's hidden by the text window.  Also, since there
must be a text window to allow printing (including the printing of the
Logo prompt), Logo automatically switches from fullscreen to splitscreen
whenever anything is printed.  [This design decision follows from the
scarcity of memory, so that the extra memory to remember an invisible
part of a drawing seems too expensive.]


File: ucblogo.info,  Node: SPLITSCREEN,  Next: SETSCRUNCH,  Prev: FULLSCREEN,  Up: TURTLE AND WINDOW CONTROL

splitscreen
-----------

     SPLITSCREEN
     SS

rearranges the size and position of windows to allow some room for text
interaction while also keeping most of the graphics window visible.  The
details differ among machines.  Compare TEXTSCREEN and FULLSCREEN.

*Note TEXTSCREEN:: .


File: ucblogo.info,  Node: SETSCRUNCH,  Next: REFRESH,  Prev: SPLITSCREEN,  Up: TURTLE AND WINDOW CONTROL

setscrunch
----------

     SETSCRUNCH xscale yscale

adjusts the aspect ratio and scaling of the graphics display.  After
this command is used, all further turtle motion will be adjusted by
multiplying the horizontal and vertical extent of the motion by the two
numbers given as inputs.  For example, after the instruction
`SETSCRUNCH 2 1' motion at a heading of 45 degrees will move twice as
far horizontally as vertically.  If your squares don't come out square,
try this.  (Alternatively, you can deliberately misadjust the aspect
ratio to draw an ellipse.)

For Unix machines and Macintoshes, both scale factors are initially 1.
For DOS machines, the scale factors are initially set according to what
the hardware claims the aspect ratio is, but the hardware sometimes
lies.  The values set by SETSCRUNCH are remembered in a file (called
SCRUNCH.DAT) and are automatically put into effect when a Logo session
begins.


File: ucblogo.info,  Node: REFRESH,  Next: NOREFRESH,  Prev: SETSCRUNCH,  Up: TURTLE AND WINDOW CONTROL

refresh
-------

     REFRESH

tells Logo to remember the turtle's motions so that they can be
reconstructed in case the graphics window is overlayed.  The
effectiveness of this command may depend on the machine used.


File: ucblogo.info,  Node: NOREFRESH,  Prev: REFRESH,  Up: TURTLE AND WINDOW CONTROL

norefresh
---------

     NOREFRESH

tells Logo not to remember the turtle's motions.  This will make drawing
faster, but prevents recovery if the window is overlayed.


File: ucblogo.info,  Node: TURTLE AND WINDOW QUERIES,  Next: PEN AND BACKGROUND CONTROL,  Prev: TURTLE AND WINDOW CONTROL,  Up: GRAPHICS

Turtle and Window Queries
=========================

* Menu:

* SHOWNP::
* SCREENMODE::
* TURTLEMODE::


File: ucblogo.info,  Node: SHOWNP,  Next: SCREENMODE,  Prev: TURTLE AND WINDOW QUERIES,  Up: TURTLE AND WINDOW QUERIES

shownp
------

     SHOWNP
     SHOWN?

outputs TRUE if the turtle is shown (visible), FALSE if the turtle is
hidden.  See SHOWTURTLE and HIDETURTLE.

*Note SHOWTURTLE:: , *Note HIDETURTLE:: .


File: ucblogo.info,  Node: SCREENMODE,  Next: TURTLEMODE,  Prev: SHOWNP,  Up: TURTLE AND WINDOW QUERIES

screenmode
----------

     SCREENMODE

outputs the word TEXTSCREEN, SPLITSCREEN, or FULLSCREEN depending on
the current screen mode.


File: ucblogo.info,  Node: TURTLEMODE,  Prev: SCREENMODE,  Up: TURTLE AND WINDOW QUERIES

turtlemode
----------

     TURTLEMODE

outputs the word WRAP, FENCE, or WINDOW depending on the current turtle
mode.


File: ucblogo.info,  Node: PEN AND BACKGROUND CONTROL,  Next: PEN QUERIES,  Prev: TURTLE AND WINDOW QUERIES,  Up: GRAPHICS

Pen and Background Control
==========================

The turtle carries a pen that can draw pictures.  At any time the pen
can be UP (in which case moving the turtle does not change what's on the
graphics screen) or DOWN (in which case the turtle leaves a trace).  If
the pen is down, it can operate in one of three modes: PAINT (so that it
draws lines when the turtle moves), ERASE (so that it erases any lines
that might have been drawn on or through that path earlier), or REVERSE
(so that it inverts the status of each point along the turtle's path).

* Menu:

* PENDOWN::
* PENUP::
* PENPAINT::
* PENERASE::
* PENREVERSE::
* SETPENCOLOR::
* SETPALETTE::
* SETPENSIZE::
* SETPENPATTERN::
* SETPEN::
* SETBACKGROUND::


File: ucblogo.info,  Node: PENDOWN,  Next: PENUP,  Prev: PEN AND BACKGROUND CONTROL,  Up: PEN AND BACKGROUND CONTROL

pendown
-------

     PENDOWN
     PD

sets the pen's position to DOWN, without changing its mode.


File: ucblogo.info,  Node: PENUP,  Next: PENPAINT,  Prev: PENDOWN,  Up: PEN AND BACKGROUND CONTROL

penup
-----

     PENUP
     PU

sets the pen's position to UP, without changing its mode.


File: ucblogo.info,  Node: PENPAINT,  Next: PENERASE,  Prev: PENUP,  Up: PEN AND BACKGROUND CONTROL

penpaint
--------

     PENPAINT
     PPT

sets the pen's position to DOWN and mode to PAINT.


File: ucblogo.info,  Node: PENERASE,  Next: PENREVERSE,  Prev: PENPAINT,  Up: PEN AND BACKGROUND CONTROL

penerase
--------

     PENERASE
     PE

sets the pen's position to DOWN and mode to ERASE.

*Note ERASE:: .


File: ucblogo.info,  Node: PENREVERSE,  Next: SETPENCOLOR,  Prev: PENERASE,  Up: PEN AND BACKGROUND CONTROL

penreverse
----------

     PENREVERSE
     PX

sets the pen's position to DOWN and mode to REVERSE.  (This may interact
in hardware-dependent ways with use of color.)

*Note REVERSE:: .


File: ucblogo.info,  Node: SETPENCOLOR,  Next: SETPALETTE,  Prev: PENREVERSE,  Up: PEN AND BACKGROUND CONTROL

setpencolor
-----------

     SETPENCOLOR colornumber.or.rgblist
     SETPC colornumber.or.rgblist

sets the pen color to the given number, which must be a nonnegative
integer.  There are initial assignments for the first 16 colors:

      0  black	 1  blue	 2  green	 3  cyan
      4  red		 5  magenta	 6  yellow	 7 white
      8  brown	 9  tan		10  forest	11  aqua
     12  salmon	13  purple	14  orange	15  grey

but other colors can be assigned to numbers by the PALETTE command.
Alternatively, sets the pen color to the given RGB values (a list of
three nonnegative integers less than 64K (65536) specifying the amount
of red, green, and blue in the desired color).


File: ucblogo.info,  Node: SETPALETTE,  Next: SETPENSIZE,  Prev: SETPENCOLOR,  Up: PEN AND BACKGROUND CONTROL

setpalette
----------

     SETPALETTE colornumber rgblist

sets the actual color corresponding to a given number, if allowed by the
hardware and operating system.  Colornumber must be an integer greater
than or equal to 8.  (Logo tries to keep the first 8 colors constant.)
The second input is a list of three nonnegative integers less than 64K
(65536) specifying the amount of red, green, and blue in the desired
color.  The actual color resolution on any screen is probably less than
64K, but Logo scales as needed.


File: ucblogo.info,  Node: SETPENSIZE,  Next: SETPENPATTERN,  Prev: SETPALETTE,  Up: PEN AND BACKGROUND CONTROL

setpensize
----------

     SETPENSIZE size

sets the thickness of the pen.  The input is either a single positive
integer or a list of two positive integers (for horizontal and vertical
thickness).  Some versions pay no attention to the second number, but
always have a square pen.

     SETPENPATTERN pattern

sets hardware-dependent pen characteristics.  This command is not
guaranteed compatible between implementations on different machines.


File: ucblogo.info,  Node: SETPENPATTERN,  Next: SETPEN,  Prev: SETPENSIZE,  Up: PEN AND BACKGROUND CONTROL

setpenpattern
-------------

     SETPENSIZE size
     SETPENPATTERN pattern

set hardware-dependent pen characteristics.  These commands are not
guaranteed compatible between implementations on different machines.


File: ucblogo.info,  Node: SETPEN,  Next: SETBACKGROUND,  Prev: SETPENPATTERN,  Up: PEN AND BACKGROUND CONTROL

setpen
------

     SETPEN list					(library procedure)

sets the pen's position, mode, thickness, and hardware-dependent
characteristics according to the information in the input list, which
should be taken from an earlier invocation of PEN.

*Note PEN:: .


File: ucblogo.info,  Node: SETBACKGROUND,  Prev: SETPEN,  Up: PEN AND BACKGROUND CONTROL

setbackground
-------------

     SETBACKGROUND colornumber.or.rgblist
     SETBG colornumber.or.rgblist

set the screen background color by slot number or RGB values.  See
SETPENCOLOR for details.

*Note SETPENCOLOR:: .


File: ucblogo.info,  Node: PEN QUERIES,  Next: SAVING AND LOADING PICTURES,  Prev: PEN AND BACKGROUND CONTROL,  Up: GRAPHICS

Pen Queries
===========

* Menu:

* PENDOWNP::
* PENMODE::
* PENCOLOR::
* PALETTE::
* PENSIZE::
* PEN::
* BACKGROUND::


File: ucblogo.info,  Node: PENDOWNP,  Next: PENMODE,  Prev: PEN QUERIES,  Up: PEN QUERIES

pendownp
--------

     PENDOWNP
     PENDOWN?

outputs TRUE if the pen is down, FALSE if it's up.


File: ucblogo.info,  Node: PENMODE,  Next: PENCOLOR,  Prev: PENDOWNP,  Up: PEN QUERIES

penmode
-------

     PENMODE

outputs one of the words PAINT, ERASE, or REVERSE according to the
current pen mode.

*Note ERASE:: , *Note REVERSE:: .


File: ucblogo.info,  Node: PENCOLOR,  Next: PALETTE,  Prev: PENMODE,  Up: PEN QUERIES

pencolor
--------

     PENCOLOR
     PC

outputs a color number, a nonnegative integer that is associated with a
particular color, or a list of RGB values if such a list was used as
the most recent input to SETPENCOLOR.  There are initial assignments
for the first 16 colors:

     	 0  black        1  blue         2  green        3  cyan
     	 4  red          5  magenta      6  yellow       7 white
     	 8  brown        9  tan         10  forest      11  aqua
     	12  salmon      13  purple      14  orange      15  grey

but other colors can be assigned to numbers by the PALETTE command.


File: ucblogo.info,  Node: PALETTE,  Next: PENSIZE,  Prev: PENCOLOR,  Up: PEN QUERIES

palette
-------

     PALETTE colornumber

outputs a list of three integers, each in the range 0-65535,
representing the amount of red, green, and blue in the color associated
with the given number.


File: ucblogo.info,  Node: PENSIZE,  Next: PEN,  Prev: PALETTE,  Up: PEN QUERIES

pensize
-------

     PENSIZE

outputs a list of two positive integers, specifying the horizontal and
vertical thickness of the turtle pen.  (In some implementations the two
numbers may always be equal.)

     PENPATTERN

outputs hardware-specific pen information.


File: ucblogo.info,  Node: PEN,  Next: BACKGROUND,  Prev: PENSIZE,  Up: PEN QUERIES

pen
---

     PEN						(library procedure)

outputs a list containing the pen's position, mode, thickness, and
hardware-specific characteristics, for use by SETPEN.

*Note SETPEN:: .

