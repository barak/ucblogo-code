This is ucblogo.info, produced by makeinfo version 4.5 from
usermanual.texi.


File: ucblogo.info,  Node: THROW,  Next: ERROR,  Prev: CATCH,  Up: CONTROL

throw
-----

     THROW tag
     (THROW tag value)

command.  Must be used within the scope of a CATCH with an equal tag.
Ends the running of the instructionlist of the CATCH.  If THROW is used
with only one input, the corresponding CATCH does not output a value.
If THROW is used with two inputs, the second provides an output for the
CATCH.

THROW "TOPLEVEL can be used to terminate all running procedures and
interactive pauses, and return to the toplevel instruction prompt.
Typing the system interrupt character (normally <control-C> for Unix,
<control-Q> for DOS, or <command-period> for Mac) has the same effect.

THROW "ERROR can be used to generate an error condition.  If the error
is not caught, it prints a message (THROW "ERROR) with the usual
indication of where the error (in this case the THROW) occurred.  If a
second input is used along with a tag of ERROR, that second input is
used as the text of the error message instead of the standard message.
Also, in this case, the location indicated for the error will be, not
the location of the THROW, but the location where the procedure
containing the THROW was invoked.  This allows user-defined procedures
to generate error messages as if they were primitives.  Note: in this
case the corresponding CATCH "ERROR, if any, does not output, since the
second input to THROW is not considered a return value.

THROW "SYSTEM immediately leaves Logo, returning to the operating
system, without printing the usual parting message and without deleting
any editor temporary file written by EDIT.

*Note EDIT:: .


File: ucblogo.info,  Node: ERROR,  Next: PAUSE,  Prev: THROW,  Up: CONTROL

error
-----

     ERROR

outputs a list describing the error just caught, if any.  If there was
not an error caught since the last use of ERROR, the empty list will be
output.  The error list contains four members: an integer code
corresponding to the type of error, the text of the error message, the
name of the procedure in which the error occurred, and the instruction
line on which the error occurred.


File: ucblogo.info,  Node: PAUSE,  Next: CONTINUE,  Prev: ERROR,  Up: CONTROL

pause
-----

     PAUSE

command or operation.  Enters an interactive pause.  The user is
prompted for instructions, as at toplevel, but with a prompt that
includes the name of the procedure in which PAUSE was invoked.  Local
variables of that procedure are available during the pause.  PAUSE
outputs if the pause is ended by a CONTINUE with an input.

If the variable ERRACT exists, and an error condition occurs, the
contents of that variable are run as an instructionlist.  Typically
ERRACT is given the value [PAUSE] so that an interactive pause will be
entered on the event of an error.  This allows the user to check values
of local variables at the time of the error.

Typing the system quit character (normally <control-\> for Unix,
<control-W> for DOS, or <command-comma> for Mac) will also enter a
pause.

*Note ERRACT:: .


File: ucblogo.info,  Node: CONTINUE,  Next: WAIT,  Prev: PAUSE,  Up: CONTROL

continue
--------

     CONTINUE value
     CO value
     (CONTINUE)
     (CO)

command.  Ends the current interactive pause, returning to the context
of the PAUSE invocation that began it.  If CONTINUE is given an input,
that value is used as the output from the PAUSE.  If not, the PAUSE does
not output.

Exceptionally, the CONTINUE command can be used without its default
input and without parentheses provided that nothing follows it on the
instruction line.


File: ucblogo.info,  Node: WAIT,  Next: BYE,  Prev: CONTINUE,  Up: CONTROL

wait
----

     WAIT time

command.  Delays further execution for `time' 60ths of a second.  Also
causes any buffered characters destined for the terminal to be printed
immediately.  WAIT 0 can be used to achieve this buffer flushing
without actually waiting.


File: ucblogo.info,  Node: BYE,  Next: dMAYBEOUTPUT,  Prev: WAIT,  Up: CONTROL

bye
---

     BYE

command.  Exits from Logo; returns to the operating system.


File: ucblogo.info,  Node: dMAYBEOUTPUT,  Next: GOTO,  Prev: BYE,  Up: CONTROL

.maybeoutput
------------

     .MAYBEOUTPUT value				(special form)

works like OUTPUT except that the expression that provides the input
value might not, in fact, output a value, in which case the effect is
like STOP.  This is intended for use in control structure definitions,
for cases in which you don't know whether or not some expression
produces a value.  Example:

     to invoke :function [:inputs] 2
     .maybeoutput apply :function :inputs
     end
     
     ? (invoke "print "a "b "c)
     a b c
     ? print (invoke "word "a "b "c)
     abc

This is an alternative to RUNRESULT.  It's fast and easy to use, at the
cost of being an exception to Logo's evaluation rules.  (Ordinarily, it
should be an error if the expression that's supposed to provide an input
to something doesn't have a value.)

*Note OUTPUT:: , *Note STOP:: , *Note RUNRESULT:: .


File: ucblogo.info,  Node: GOTO,  Next: TAG,  Prev: dMAYBEOUTPUT,  Up: CONTROL

goto
----

     GOTO word

command.  Looks for a TAG command with the same input in the same
procedure, and continues running the procedure from the location of that
TAG.  It is meaningless to use GOTO outside of a procedure.


File: ucblogo.info,  Node: TAG,  Next: IGNORE,  Prev: GOTO,  Up: CONTROL

tag
---

     TAG quoted.word

command.  Does nothing.  The input must be a literal word following a
quotation mark ("), not the result of a computation.  Tags are used by
the GOTO command.


File: ucblogo.info,  Node: IGNORE,  Next: back-quote,  Prev: TAG,  Up: CONTROL

ignore
------

     IGNORE value					(library procedure)

command.  Does nothing.  Used when an expression is evaluated for a side
effect and its actual value is unimportant.


File: ucblogo.info,  Node: back-quote,  Next: FOR,  Prev: IGNORE,  Up: CONTROL

`
-

     ` list						(library procedure)

outputs a list equal to its input but with certain substitutions.  If a
member of the input list is the word `,' (comma) then the following
member should be an instructionlist that produces an output when run.
That output value replaces the comma and the instructionlist.  If a
member of the input list is the word `,@' (comma atsign) then the
following member should be an instructionlist that outputs a list when
run.  The members of that list replace the `,@' and the instructionlist.
Example:

     show `[foo baz ,[bf [a b c]] garply ,@[bf [a b c]]]

will print

     [foo baz [b c] garply b c]

A word starting with `,' or `,@' is treated as if the rest of the word
were a one-word list, e.g., `,:foo' is equivalent to `,[:Foo]'.

A word starting with `",' (quote comma) or `:,' (colon comma) becomes a
word starting with `"' or `:' but with the result of running the
substitution (or its first word, if the result is a list) replacing
what comes after the comma.

Backquotes can be nested.  Substitution is done only for commas at the
same depth as the backquote in which they are found:

     ? show `[a `[b ,[1+2] ,[foo ,[1+3] d] e] f]
     [a ` [b , [1+2] , [foo 4 d] e] f]
     
     ?make "name1 "x
     ?make "name2 "y
     ? show `[a `[b ,:,:name1 ,",:name2 d] e]
     [a ` [b , [:x] , ["y] d] e]


File: ucblogo.info,  Node: FOR,  Next: DOdWHILE,  Prev: back-quote,  Up: CONTROL

for
---

     FOR forcontrol instructionlist			(library procedure)

command.  The first input must be a list containing three or four
members: (1) a word, which will be used as the name of a local variable;
(2) a word or list that will be evaluated as by RUN to determine a
number, the starting value of the variable; (3) a word or list that will
be evaluated to determine a number, the limit value of the variable; (4)
an optional word or list that will be evaluated to determine the step
size.  If the fourth member is missing, the step size will be 1 or -1
depending on whether the limit value is greater than or less than the
starting value, respectively.

The second input is an instructionlist.  The effect of FOR is to run
that instructionlist repeatedly, assigning a new value to the control
variable (the one named by the first member of the forcontrol list) each
time.  First the starting value is assigned to the control variable.
Then the value is compared to the limit value.  FOR is complete when the
sign of (current-limit) is the same as the sign of the step size.  (If
no explicit step size is provided, the instructionlist is always run at
least once.  An explicit step size can lead to a zero-trip FOR, e.g.,
FOR [I 1 0 1] ...). Otherwise, the instructionlist is run, then the
step is added to the current value of the control variable and FOR
returns to the comparison step.

     ? for [i 2 7 1.5] [print :i]
     2
     3.5
     5
     6.5
     ?

*Note RUN:: .


File: ucblogo.info,  Node: DOdWHILE,  Next: WHILE,  Prev: FOR,  Up: CONTROL

do.while
--------

     DO.WHILE instructionlist tfexpression		(library procedure)

command.  Repeatedly evaluates the `instructionlist' as long as the
evaluated `tfexpression' remains TRUE.  Evaluates the first input first,
so the `instructionlist' is always run at least once.  The
`tfexpression' must be an expressionlist whose value when evaluated is
TRUE or FALSE.


File: ucblogo.info,  Node: WHILE,  Next: DOdUNTIL,  Prev: DOdWHILE,  Up: CONTROL

while
-----

     WHILE tfexpression instructionlist		(library procedure)

command.  Repeatedly evaluates the `instructionlist' as long as the
evaluated `tfexpression' remains TRUE.  Evaluates the first input first,
so the `instructionlist' may never be run at all.  The `tfexpression'
must be an expressionlist whose value when evaluated is TRUE or FALSE.


File: ucblogo.info,  Node: DOdUNTIL,  Next: UNTIL,  Prev: WHILE,  Up: CONTROL

do.until
--------

     DO.UNTIL instructionlist tfexpression		(library procedure)

command.  Repeatedly evaluates the `instructionlist' as long as the
evaluated `tfexpression' remains FALSE.  Evaluates the first input
first, so the `instructionlist' is always run at least once.  The
`tfexpression' must be an expressionlist whose value when evaluated is
TRUE or FALSE.


File: ucblogo.info,  Node: UNTIL,  Next: CASE,  Prev: DOdUNTIL,  Up: CONTROL

until
-----

     UNTIL tfexpression instructionlist		(library procedure)

command.  Repeatedly evaluates the `instructionlist' as long as the
evaluated `tfexpression' remains FALSE.  Evaluates the first input
first, so the `instructionlist' may never be run at all.  The
`tfexpression' must be an expressionlist whose value when evaluated is
TRUE or FALSE.


File: ucblogo.info,  Node: CASE,  Next: COND,  Prev: UNTIL,  Up: CONTROL

case
----

     CASE value clauses					(library procedure)

command or operation.  The second input is a list of lists (clauses);
each clause is a list whose first element is either a list of values or
the word ELSE and whose butfirst is a Logo expression or instruction.
CASE examines the clauses in order.  If a clause begins with the word
ELSE (upper or lower case), then the butfirst of that clause is
evaluated and CASE outputs its value, if any.  If the first input to
CASE is a member of the first element of a clause, then the butfirst of
that clause is evaluated and CASE outputs its value, if any.  If
neither of these conditions is met, then CASE goes on to the next
clause.  If no clause is satisfied, CASE does nothing.  Example:

     to vowelp :letter
     output case :letter [ [[a e i o u] "true] [else "false] ]
     end


File: ucblogo.info,  Node: COND,  Prev: CASE,  Up: CONTROL

cond
----

     COND clauses						(library procedure)

command or operation.  The input is a list of lists (clauses); each
clause is a list whose first element is either an expression whose
value is TRUE or FALSE, or the word ELSE, and whose butfirst is a Logo
expression or instruction.  COND examines the clauses in order.  If a
clause begins with the word ELSE (upper or lower case), then the
butfirst of that clause is evaluated and CASE outputs its value, if
any.  Otherwise, the first element of the clause is evaluated; the
resulting value must be TRUE or FALSE.  If it's TRUE, then the butfirst
of that clause is evaluated and COND outputs its value, if any.  If the
value is FALSE, then COND goes on to the next clause.  If no clause is
satisfied, COND does nothing.  Example:

     to evens :numbers	; select even numbers from a list
     op cond [ [[emptyp :numbers] []]
               [[evenp first :numbers]	; assuming EVENP is defined
                fput first :numbers evens butfirst :numbers]
               [else evens butfirst :numbers] ]
     end


File: ucblogo.info,  Node: TEMPLATE-BASED ITERATION,  Prev: CONTROL,  Up: CONTROL STRUCTURES

Template-based Iteration
========================

The procedures in this section are iteration tools based on the idea of
a `template.'  This is a generalization of an instruction list or an
expression list in which `slots' are provided for the tool to insert
varying data.  Four different forms of template can be used.

The most commonly used form for a template is `explicit-slot' form, or
`question mark' form.  Example:

     ? show map [? * ?] [2 3 4 5]
     [4 9 16 25]
     ?

In this example, the MAP tool evaluated the template [? * ?] repeatedly,
with each of the members of the data list [2 3 4 5] substituted in turn
for the question marks.  The same value was used for every question mark
in a given evaluation.  Some tools allow for more than one datum to be
substituted in parallel; in these cases the slots are indicated by ?1
for the first datum, ?2 for the second, and so on:

     ? show (map [(word ?1 ?2 ?1)] [a b c] [d e f])
     [ada beb cfc]
     ?

If the template wishes to compute the datum number, the form (? 1) is
equivalent to ?1, so (? ?1) means the datum whose number is given in
datum number 1.  Some tools allow additional slot designations, as shown
in the individual descriptions.

The second form of template is the `named-procedure' form.  If the
template is a word rather than a list, it is taken as the name of a
procedure.  That procedure must accept a number of inputs equal to the
number of parallel data slots provided by the tool; the procedure is
applied to all of the available data in order.  That is, if data ?1
through ?3 are available, the template "PROC is equivalent to
[PROC ?1 ?2 ?3].

     ? show (map "word [a b c] [d e f])
     [ad be cf]
     ?
     
     to dotprod :a :b	; vector dot product
     op apply "sum (map "product :a :b)
     end

The third form of template is `named-slot' or `lambda' form.  This form
is indicated by a template list containing more than one member, whose
first member is itself a list.  The first member is taken as a list of
names; local variables are created with those names and given the
available data in order as their values.  The number of names must
equal the number of available data.  This form is needed primarily when
one iteration tool must be used within the template list of another,
and the ? notation would be ambiguous in the inner template.  Example:

     to matmul :m1 :m2 [:tm2 transpose :m2]	; multiply two matrices
     output map [[row] map [[col] dotprod :row :col] :tm2] :m1
     end

The fourth form is `procedure text' form, a variant of lambda form.  In
this form, the template list contains at least two members, all of
which are lists.  This is the form used by the DEFINE and TEXT
primitives, and APPLY accepts it so that the text of a defined
procedure can be used as a template.

Note:  The fourth form of template is interpreted differently from the
others, in that Logo considers it to be an independent defined procedure
for the purposes of OUTPUT and STOP.  For example, the following two
instructions are identical:

     ? print apply [[x] :x+3] [5]
     8
     ? print apply [[x] [output :x+3]] [5]
     8

although the first instruction is in named-slot form and the second is
in procedure-text form.  The named-slot form can be understood as
telling Logo to evaluate the expression :x+3 in place of the entire
invocation of apply, with the variable x temporarily given the value 5.
The procedure-text form can be understood as invoking the procedure

     to foo :x
     output :x+3
     end

with input 5, but without actually giving the procedure a name.  If the
use of OUTPUT were interchanged in these two examples, we'd get errors:

     ? print apply [[x] output :x+3] [5]
     Can only use output inside a procedure
     ? print apply [[x] [:x+3]] [5]
     You don't say what to do with 8

The named-slot form can be used with STOP or OUTPUT inside a procedure,
to stop the enclosing procedure.

The following iteration tools are extended versions of the ones in
Appendix B of the book _Computer_Science_Logo_Style,_Volume_3:
_Advanced_Topics_ by Brian Harvey [MIT Press, 1987].  The extensions
are primarily to allow for variable numbers of inputs.

* Menu:

* APPLY::
* INVOKE::
* FOREACH::
* MAP::
* MAPdSE::                      MAP.SE
* FILTER::
* FIND::
* REDUCE::
* CROSSMAP::
* CASCADE::
* CASCADEd2::                   CASCADE.2
* TRANSFER::


File: ucblogo.info,  Node: APPLY,  Next: INVOKE,  Prev: TEMPLATE-BASED ITERATION,  Up: TEMPLATE-BASED ITERATION

apply
-----

     APPLY template inputlist

command or operation.  Runs the "template," filling its slots with the
members of `inputlist.'  The number of members in `inputlist' must be an
acceptable number of slots for `template.'  It is illegal to apply the
primitive TO as a template, but anything else is okay.  APPLY outputs
what `template' outputs, if anything.

*Note TO:: .


File: ucblogo.info,  Node: INVOKE,  Next: FOREACH,  Prev: APPLY,  Up: TEMPLATE-BASED ITERATION

invoke
------

     INVOKE template input				(library procedure)
     (INVOKE template input1 input2 ...)

command or operation.  Exactly like APPLY except that the inputs are
provided as separate expressions rather than in a list.


File: ucblogo.info,  Node: FOREACH,  Next: MAP,  Prev: INVOKE,  Up: TEMPLATE-BASED ITERATION

foreach
-------

     FOREACH data template				(library procedure)
     (FOREACH data1 data2 ... template)

command.  Evaluates the template list repeatedly, once for each member
of the data list.  If more than one data list are given, each of them
must be the same length.  (The data inputs can be words, in which case
the template is evaluated once for each character.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by [C D E].
If multiple parallel slots are used, then (?REST 1) goes with ?1, etc.

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.


File: ucblogo.info,  Node: MAP,  Next: MAPdSE,  Prev: FOREACH,  Up: TEMPLATE-BASED ITERATION

map
---

     MAP template data				(library procedure)
     (MAP template data1 data2 ...)

outputs a word or list, depending on the type of the data input, of the
same length as that data input.  (If more than one data input are given,
the output is of the same type as data1.)  Each member of the output is
the result of evaluating the template list, filling the slots with the
corresponding member(s) of the data input(s).  (All data inputs must be
the same length.)  In the case of a word output, the results of the
template evaluation must be words, and they are concatenated with WORD.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by
[C D E]. If multiple parallel slots are used, then (?REST 1) goes with
?1, etc.

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.

*Note WORD:: .


File: ucblogo.info,  Node: MAPdSE,  Next: FILTER,  Prev: MAP,  Up: TEMPLATE-BASED ITERATION

map.se
------

     MAP.SE template data				(library procedure)
     (MAP.SE template data1 data2 ...)

outputs a list formed by evaluating the template list repeatedly and
concatenating the results using SENTENCE.  That is, the members of the
output are the members of the results of the evaluations.  The output
list might, therefore, be of a different length from that of the data
input(s).  (If the result of an evaluation is the empty list, it
contributes nothing to the final output.)  The data inputs may be words
or lists.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by
[C D E]. If multiple parallel slots are used, then (?REST 1) goes with
?1, etc.

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.

*Note SENTENCE:: .


File: ucblogo.info,  Node: FILTER,  Next: FIND,  Prev: MAPdSE,  Up: TEMPLATE-BASED ITERATION

filter
------

     FILTER tftemplate data				(library procedure)

outputs a word or list, depending on the type of the data input,
containing a subset of the members (for a list) or characters (for a
word) of the input.  The template is evaluated once for each member or
character of the data, and it must produce a TRUE or FALSE value.  If
the value is TRUE, then the corresponding input constituent is included
in the output.

     ? print filter "vowelp "elephant
     eea
     ?

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by [C D E].

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.


File: ucblogo.info,  Node: FIND,  Next: REDUCE,  Prev: FILTER,  Up: TEMPLATE-BASED ITERATION

find
----

     FIND tftemplate data				(library procedure)

outputs the first constituent of the data input (the first member of a
list, or the first character of a word) for which the value produced by
evaluating the template with that consituent in its slot is TRUE.  If
there is no such constituent, the empty list is output.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by [C D E].

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.


File: ucblogo.info,  Node: REDUCE,  Next: CROSSMAP,  Prev: FIND,  Up: TEMPLATE-BASED ITERATION

reduce
------

     REDUCE template data				(library procedure)

outputs the result of applying the template to accumulate the members of
the data input.  The template must be a two-slot function.  Typically it
is an associative function name like "SUM.  If the data input has only
one constituent (member in a list or character in a word), the output is
that consituent.  Otherwise, the template is first applied with ?1
filled with the next-to-last consitient and ?2 with the last
constituent.  Then, if there are more constituents, the template is
applied with ?1 filled with the next constituent to the left and ?2 with
the result from the previous evaluation.  This process continues until
all constituents have been used.  The data input may not be empty.

Note: If the template is, like SUM, the name of a procedure that is
capable of accepting arbitrarily many inputs, it is more efficient to
use APPLY instead of REDUCE.  The latter is good for associative
procedures that have been written to accept exactly two inputs:

     to max :a :b
     output ifelse :a > :b [:a] [:b]
     end

     print reduce "max [...]

Alternatively, REDUCE can be used to write MAX as a procedure that
accepts any number of inputs, as SUM does:

     to max [:inputs] 2
     if emptyp :inputs ~
        [(throw "error [not enough inputs to max])]
     output reduce [ifelse ?1 > ?2 [?1] [?2]] :inputs
     end

*Note SUM:: , *Note APPLY:: .


File: ucblogo.info,  Node: CROSSMAP,  Next: CASCADE,  Prev: REDUCE,  Up: TEMPLATE-BASED ITERATION

crossmap
--------

     CROSSMAP template listlist			(library procedure)
     (CROSSMAP template data1 data2 ...)

outputs a list containing the results of template evaluations.  Each
data list contributes to a slot in the template; the number of slots is
equal to the number of data list inputs.  As a special case, if only one
data list input is given, that list is taken as a list of data lists,
and each of its members contributes values to a slot.  CROSSMAP differs
from MAP in that instead of taking members from the data inputs in
parallel, it takes all possible combinations of members of data inputs,
which need not be the same length.

     ? show (crossmap [word ?1 ?2] [a b c] [1 2 3 4])
     [a1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4]
     ?

For compatibility with the version in the first edition of CSLS (1),
CROSSMAP templates may use the notation :1 instead of ?1 to indicate
slots.

*Note MAP:: .

---------- Footnotes ----------

(1) Computer Science Logo Style


File: ucblogo.info,  Node: CASCADE,  Next: CASCADEd2,  Prev: CROSSMAP,  Up: TEMPLATE-BASED ITERATION

cascade
-------

     CASCADE endtest template startvalue		(library procedure)
     (CASCADE endtest tmp1 sv1 tmp2 sv2 ...)
     (CASCADE endtest tmp1 sv1 tmp2 sv2 ... finaltemplate)

outputs the result of applying a template (or several templates, as
explained below) repeatedly, with a given value filling the slot the
first time, and the result of each application filling the slot for the
following application.

In the simplest case, CASCADE has three inputs.  The second input is a
one-slot expression template.  That template is evaluated some number of
times (perhaps zero).  On the first evaluation, the slot is filled with
the third input; on subsequent evaluations, the slot is filled with the
result of the previous evaluation.  The number of evaluations is
determined by the first input.  This can be either a nonnegative
integer, in which case the template is evaluated that many times, or a
predicate expression template, in which case it is evaluated (with the
same slot filler that will be used for the evaluation of the second
input) repeatedly, and the CASCADE evaluation continues as long as the
predicate value is FALSE.  (In other words, the predicate template
indicates the condition for stopping.)

If the template is evaluated zero times, the output from CASCADE is the
third (startvalue) input.  Otherwise, the output is the value produced
by the last template evaluation.

CASCADE templates may include the symbol # to represent the number of
times the template has been evaluated.  This slot is filled with 1 for
the first evaluation, 2 for the second, and so on.

     ? show cascade 5 [lput # ?] []
     [1 2 3 4 5]
     ? show cascade [vowelp first ?] [bf ?] "spring
     ing
     ? show cascade 5 [# * ?] 1
     120
     ?

Several cascaded results can be computed in parallel by providing
additional template-startvalue pairs as inputs to CASCADE.  In this
case, all templates (including the endtest template, if used) are
multi-slot, with the number of slots equal to the number of pairs of
inputs.  In each round of evaluations, ?2 represents the result of
evaluating the second template in the previous round.  If the total
number of inputs (including the first endtest input) is odd, then the
output from CASCADE is the final value of the first template.  If the
total number of inputs is even, then the last input is a template that
is evaluated once, after the end test is satisfied, to determine the
output from CASCADE.

     to fibonacci :n
     output (cascade :n [?1 + ?2] 1 [?1] 0)
     end
     
     to piglatin :word
     output (cascade [vowelp first ?] ~
        [word bf ? first ?] ~
        :word ~
        [word ? "ay])
     end


File: ucblogo.info,  Node: CASCADEd2,  Next: TRANSFER,  Prev: CASCADE,  Up: TEMPLATE-BASED ITERATION

cascade.2
---------

     CASCADE.2 endtest temp1 startval1 temp2 startval2  (library procedure)

outputs the result of invoking CASCADE with the same inputs.  The only
difference is that the default number of inputs is five instead of
three.


File: ucblogo.info,  Node: TRANSFER,  Prev: CASCADEd2,  Up: TEMPLATE-BASED ITERATION

transfer
--------

     TRANSFER endtest template inbasket		(library procedure)

outputs the result of repeated evaluation of the template.  The template
is evaluated once for each member of the list `inbasket.'  TRANSFER
maintains an `outbasket' that is initially the empty list.  After each
evaluation of the template, the resulting value becomes the new
outbasket.

In the template, the symbol ?IN represents the current member from the
inbasket; the symbol ?OUT represents the entire current outbasket.
Other slot symbols should not be used.

If the first (endtest) input is an empty list, evaluation continues
until all inbasket members have been used.  If not, the first input must
be a predicate expression template, and evaluation continues until
either that template's value is TRUE or the inbasket is used up.


File: ucblogo.info,  Node: MACROS,  Next: ERROR PROCESSING,  Prev: CONTROL STRUCTURES,  Up: Top

Macros
******

* Menu:

* dMACRO::                      MACRO
* dDEFMACRO::                   DEFMACRO
* MACROP::
* MACROEXPAND::


File: ucblogo.info,  Node: dMACRO,  Next: dDEFMACRO,  Prev: MACROS,  Up: MACROS

.macro
------

     .MACRO procname :input1 :input2 ...			(special form)
     .DEFMACRO procname text

A macro is a special kind of procedure whose output is evaluated as Logo
instructions in the context of the macro's caller.  .MACRO is exactly
like TO except that the new procedure becomes a macro; .DEFMACRO is
exactly like DEFINE with the same exception.

Macros are useful for inventing new control structures comparable to
REPEAT, IF, and so on.  Such control structures can almost, but not
quite, be duplicated by ordinary Logo procedures.  For example, here is
an ordinary procedure version of REPEAT:

     to my.repeat :num :instructions
     if :num=0 [stop]
     run :instructions
     my.repeat :num-1 :instructions
     end

This version works fine for most purposes, e.g.,

     my.repeat 5 [print "hello]

But it doesn't work if the instructions to be carried out include
OUTPUT, STOP, or LOCAL.  For example, consider this procedure:

     to example
     print [Guess my secret word.  You get three guesses.]
     repeat 3 [type "|?? | ~
        if readword = "secret [pr "Right! stop]]
     print [Sorry, the word was "secret"!]
     end

This procedure works as written, but if MY.REPEAT is used instead of
REPEAT, it won't work because the STOP will stop MY.REPEAT instead of
stopping EXAMPLE as desired.

The solution is to make MY.REPEAT a macro.  Instead of actually carrying
out the computation, a macro must return a list containing Logo
instructions.  The contents of that list are evaluated as if they
appeared in place of the call to the macro.  Here's a macro version of
REPEAT:

     .macro my.repeat :num :instructions
     if :num=0 [output []]
     output sentence :instructions ~
        (list "my.repeat :num-1 :instructions)
     end

Every macro is an operation -- it must always output something.  Even in
the base case, MY.REPEAT outputs an empty instruction list.  To show how
MY.REPEAT works, let's take the example

     my.repeat 5 [print "hello]

For this example, MY.REPEAT will output the instruction list

     		[print "hello my.repeat 4 [print "hello]]

Logo then executes these instructions in place of the original
invocation of MY.REPEAT; this prints `hello' once and invokes another
repetition.

The technique just shown, although fairly easy to understand, has the
defect of slowness because each repetition has to construct an
instruction list for evaluation.  Another approach is to make my.repeat
a macro that works just like the non-macro version unless the
instructions to be repeated include OUTPUT or STOP:

     .macro my.repeat :num :instructions
     catch "repeat.catchtag ~
        [op repeat.done runresult [repeat1 :num :instructions]]
     op []
     end
     
     to repeat1 :num :instructions
     if :num=0 [throw "repeat.catchtag]
     run :instructions
     .maybeoutput repeat1 :num-1 :instructions
     end
     
     to repeat.done :repeat.result
     if emptyp :repeat.result [op [stop]]
     op list "output quoted first :repeat.result
     end

If the instructions do not include STOP or OUTPUT, then REPEAT1 will
reach its base case and invoke THROW.  As a result, my.repeat's last
instruction line will output an empty list, so the second evaluation of
the macro result will do nothing.  But if a STOP or OUTPUT happens, then
REPEAT.DONE will output a STOP or OUTPUT instruction that will be
re-executed in the caller's context.

The macro-defining commands have names starting with a dot because
macros are an advanced feature of Logo; it's easy to get in trouble by
defining a macro that doesn't terminate, or by failing to construct the
instruction list properly.

Lisp users should note that Logo macros are NOT special forms.  That is,
the inputs to the macro are evaluated normally, as they would be for any
other Logo procedure.  It's only the output from the macro that's
handled unusually.

Here's another example:

     .macro localmake :name :value
     output (list "local~
        word "" :name   ~
        "apply          ~
        ""make          ~
        (list :name :value))
     end

It's used this way:

     to try
     localmake "garply "hello
     print :garply
     end

LOCALMAKE outputs the list

     		[local "garply apply "make [garply hello]]

The reason for the use of APPLY is to avoid having to decide whether or
not the second input to MAKE requires a quotation mark before it.  (In
this case it would -- MAKE "GARPLY "HELLO -- but the quotation mark
would be wrong if the value were a list.)

It's often convenient to use the ` function to construct the instruction
list:

     .macro localmake :name :value
     op `[local ,[word "" :name] apply "make [,[:name] ,[:value]]]
     end

On the other hand, ` is pretty slow, since it's tree recursive and
written in Logo.

*Note TO:: , *Note DEFINE:: , *Note APPLY:: , *Note STOP:: , *Note
OUTPUT:: .


File: ucblogo.info,  Node: dDEFMACRO,  Next: MACROP,  Prev: dMACRO,  Up: MACROS

.defmacro
---------

*Note dMACRO:: .


File: ucblogo.info,  Node: MACROP,  Next: MACROEXPAND,  Prev: dDEFMACRO,  Up: MACROS

macrop
------

     MACROP name
     MACRO? name

outputs TRUE if its input is the name of a macro.


File: ucblogo.info,  Node: MACROEXPAND,  Prev: MACROP,  Up: MACROS

macroexpand
-----------

     MACROEXPAND expr				(library procedure)

takes as its input a Logo expression that invokes a macro (that is, one
that begins with the name of a macro) and outputs the the Logo
expression into which the macro would translate the input expression.

     .macro localmake :name :value
     op `[local ,[word "" :name] apply "make [,[:name] ,[:value]]]
     end
     
     ? show macroexpand [localmake "pi 3.14159]
     [local "pi apply "make [pi 3.14159]]


File: ucblogo.info,  Node: ERROR PROCESSING,  Next: SPECIAL VARIABLES,  Prev: MACROS,  Up: Top

Error Processing
****************

* Menu:

* ERROR CODES::

If an error occurs, Logo takes the following steps.  First, if there is
an available variable named ERRACT, Logo takes its value as an
instructionlist and runs the instructions.  The operation ERROR may be
used within the instructions (once) to examine the error condition.  If
the instructionlist invokes PAUSE, the error message is printed before
the pause happens.  Certain errors are "recoverable"; for one of those
errors, if the instructionlist outputs a value, that value is used in
place of the expression that caused the error.  (If ERRACT invokes
PAUSE and the user then invokes CONTINUE with an input, that input
becomes the output from PAUSE and therefore the output from the ERRACT
instructionlist.)

It is possible for an ERRACT instructionlist to produce an
inappropriate value or no value where one is needed.  As a result, the
same error condition could recur forever because of this mechanism.  To
avoid that danger, if the same error condition occurs twice in a row
from an ERRACT instructionlist without user interaction, the message
"Erract loop" is printed and control returns to toplevel.  "Without
user interaction" means that if ERRACT invokes PAUSE and the user
provides an incorrect value, this loop prevention mechanism does not
take effect and the user gets to try again.

During the running of the ERRACT instructionlist, ERRACT is locally
unbound, so an error in the ERRACT instructions themselves will not
cause a loop.  In particular, an error during a pause will not cause a
pause-within-a-pause unless the user reassigns the value [PAUSE] to
ERRACT during the pause.  But such an error will not return to
toplevel; it will remain within the original pause loop.

If there is no available ERRACT value, Logo handles the error by
generating an internal THROW "ERROR.  (A user program can also generate
an error condition deliberately by invoking THROW.)  If this throw is
not caught by a CATCH "ERROR in the user program, it is eventually
caught either by the toplevel instruction loop or by a pause loop,
which prints the error message. An invocation of CATCH "ERROR in a user
program locally unbinds ERRACT, so the effect is that whichever of
ERRACT and CATCH "ERROR is more local will take precedence.

If a floating point overflow occurs during an arithmetic operation, or a
two-input mathematical function (like POWER) is invoked with an illegal
combination of inputs, the `doesn't like' message refers to the second
operand, but should be taken as meaning the combination.

*Note ERRACT:: , *Note THROW:: , *Note ERROR:: , *Note CATCH:: , *Note
PAUSE:: , *Note CONTINUE:: .


File: ucblogo.info,  Node: ERROR CODES,  Prev: ERROR PROCESSING,  Up: ERROR PROCESSING

Error Codes
===========

Here are the numeric codes that appear as the first member of the list
output by ERROR when an error is caught, with the corresponding
messages.  Some messages may have two different codes depending on
whether or not the error is recoverable (that is, a substitute value
can be provided through the ERRACT mechanism) in the specific context.
Some messages are warnings rather than errors; these will not be
caught.  Errors 0 and 32 are so bad that Logo exits immediately.


       0	Fatal internal error (can't be caught)
       1	Out of memory
       2	Stack overflow
       3	Turtle out of bounds
       4	PROC doesn't like DATUM as input (not recoverable)
       5	PROC didn't output to PROC
       6	Not enough inputs to PROC
       7	PROC doesn't like DATUM as input (recoverable)
       8	Too much inside ()'s
       9 	You don't say what to do with DATUM
      10	')' not found
      11	VAR has no value
      12	Unexpected ')'
      13	I don't know how to PROC (recoverable)
      14	Can't find catch tag for THROWTAG
      15	PROC is already defined
      16	Stopped
      17	Already dribbling
      18	File system error
      19	Assuming you mean IFELSE, not IF (warning only)
      20	VAR shadowed by local in procedure call (warning only)
      21	Throw "Error
      22	PROC is a primitive
      23	Can't use TO inside a procedure
      24	I don't know how to PROC (not recoverable)
      25	IFTRUE/IFFALSE without TEST
      26	Unexpected ']'
      27	Unexpected '}'
      28	Couldn't initialize graphics
      29	Macro returned VALUE instead of a list
      30	You don't say what to do with VALUE
      31	Can only use STOP or OUTPUT inside a procedure
      32	APPLY doesn't like BADTHING as input
      33	END inside multi-line instruction
      34	Really out of memory (can't be caught)


File: ucblogo.info,  Node: SPECIAL VARIABLES,  Next: INTERNATIONALIZATION,  Prev: ERROR PROCESSING,  Up: Top

Special Variables
*****************

Logo takes special action if any of the following variable names exists.
They follow the normal scoping rules, so a procedure can locally set one
of them to limit the scope of its effect.  Initially, no variables exist
except for ALLOWGETSET, CASEIGNOREDP, and UNBURYONEDIT, which are TRUE
and buried.

* Menu:

* ALLOWGETSET::
* CASEIGNOREDP::
* ERRACT::
* FULLPRINTP::
* LOADNOISILY::
* PRINTDEPTHLIMIT::
* PRINTWIDTHLIMIT::
* REDEFP::
* STARTUP::
* UNBURYONEDIT::
* USEALTERNATENAMES::


File: ucblogo.info,  Node: ALLOWGETSET,  Next: CASEIGNOREDP,  Prev: SPECIAL VARIABLES,  Up: SPECIAL VARIABLES

allowgetset
-----------

     ALLOWGETSET                           (variable)

if TRUE, indicates that an attempt to use a procedure that doesn't exist
should be taken as an implicit getter or setter procedure (setter if the
first three letters of the name are SET) for a variable of the same name
(without the SET if appropriate).


File: ucblogo.info,  Node: CASEIGNOREDP,  Next: ERRACT,  Prev: ALLOWGETSET,  Up: SPECIAL VARIABLES

caseignoredp
------------

     CASEIGNOREDP                                (variable)

if TRUE, indicates that lower case and upper case letters should be
considered equal by EQUALP, BEFOREP, MEMBERP, etc.  Logo initially makes
this variable TRUE, and buries it.

*Note EQUALP:: , *Note BEFOREP:: , *Note MEMBERP:: .


File: ucblogo.info,  Node: ERRACT,  Next: FULLPRINTP,  Prev: CASEIGNOREDP,  Up: SPECIAL VARIABLES

erract
------

     ERRACT                                      (variable)

an instructionlist that will be run in the event of an error.  Typically
has the value [PAUSE] to allow interactive debugging.

*Note PAUSE:: .


File: ucblogo.info,  Node: FULLPRINTP,  Next: LOADNOISILY,  Prev: ERRACT,  Up: SPECIAL VARIABLES

fullprintp
----------

     FULLPRINTP

if TRUE, then words that were created using backslash or vertical bar
(to include characters that would otherwise not be treated as part of a
word) are printed with the backslashes or vertical bars shown, so that
the printed result could be re-read by Logo to produce the same value.
If FULLPRINTP is TRUE then the empty word (however it was created)
prints as `||'.  (Otherwise it prints as nothing at all.)


File: ucblogo.info,  Node: LOADNOISILY,  Next: PRINTDEPTHLIMIT,  Prev: FULLPRINTP,  Up: SPECIAL VARIABLES

loadnoisily
-----------

     LOADNOISILY                                 (variable)

if TRUE, prints the names of procedures defined when loading from a file
(including the temporary file made by EDIT).

*Note EDIT:: .


File: ucblogo.info,  Node: PRINTDEPTHLIMIT,  Next: PRINTWIDTHLIMIT,  Prev: LOADNOISILY,  Up: SPECIAL VARIABLES

printdepthlimit
---------------

     PRINTDEPTHLIMIT                             (variable)

if a nonnegative integer, indicates the maximum depth of sublist
structure that will be printed by PRINT, etc.

*Note PRINT:: .


File: ucblogo.info,  Node: PRINTWIDTHLIMIT,  Next: REDEFP,  Prev: PRINTDEPTHLIMIT,  Up: SPECIAL VARIABLES

printwidthlimit
---------------

     PRINTWIDTHLIMIT                             (variable)

if a nonnegative integer, indicates the maximum number of members in any
one list that will be printed by PRINT, etc.

*Note PRINT:: .


File: ucblogo.info,  Node: REDEFP,  Next: STARTUP,  Prev: PRINTWIDTHLIMIT,  Up: SPECIAL VARIABLES

redefp
------

     REDEFP                                      (variable)

if TRUE, allows primitives to be erased (ERASE) or redefined (COPYDEF).

*Note ERASE:: , *Note COPYDEF:: .


File: ucblogo.info,  Node: STARTUP,  Next: UNBURYONEDIT,  Prev: REDEFP,  Up: SPECIAL VARIABLES

startup
-------

     STARTUP                                     (variable)

if assigned a list value in a file loaded by LOAD, that value is run as
an instructionlist after the loading.

*Note LOAD:: .


File: ucblogo.info,  Node: UNBURYONEDIT,  Next: USEALTERNATENAMES,  Prev: STARTUP,  Up: SPECIAL VARIABLES

unburyonedit
------------

     UNBURYONEDIT                            (variable)

if TRUE, causes any procedure defined during EDIT or LOAD to be
unburied, so that it will be saved by a later SAVE.  Files that want to
define and bury procedures must do it in that order.

*Note EDIT:: , *Note LOAD:: , *Note SAVE:: .


File: ucblogo.info,  Node: USEALTERNATENAMES,  Prev: UNBURYONEDIT,  Up: SPECIAL VARIABLES

usealternatenames
-----------------

     USEALTERNATENAMES					(variable)

if TRUE, causes Logo to generate non-English words (from the Messages
file) instead of TRUE, FALSE, END, etc.

