This is ucblogo.info, produced by makeinfo version 4.0 from
usermanual.texi.


File: ucblogo.info,  Node: INVOKE,  Next: FOREACH,  Prev: APPLY,  Up: TEMPLATE-BASED ITERATION

invoke
------

     INVOKE template input				(library procedure)
     (INVOKE template input1 input2 ...)

command or operation.  Exactly like APPLY except that the inputs are
provided as separate expressions rather than in a list.


File: ucblogo.info,  Node: FOREACH,  Next: MAP,  Prev: INVOKE,  Up: TEMPLATE-BASED ITERATION

foreach
-------

     FOREACH data template				(library procedure)
     (FOREACH data1 data2 ... template)

command.  Evaluates the template list repeatedly, once for each member
of the data list.  If more than one data list are given, each of them
must be the same length.  (The data inputs can be words, in which case
the template is evaluated once for each character.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by [C D E].
If multiple parallel slots are used, then (?REST 1) goes with ?1, etc.

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.


File: ucblogo.info,  Node: MAP,  Next: MAPdSE,  Prev: FOREACH,  Up: TEMPLATE-BASED ITERATION

map
---

     MAP template data				(library procedure)
     (MAP template data1 data2 ...)

outputs a word or list, depending on the type of the data input, of the
same length as that data input.  (If more than one data input are given,
the output is of the same type as data1.)  Each member of the output is
the result of evaluating the template list, filling the slots with the
corresponding member(s) of the data input(s).  (All data inputs must be
the same length.)  In the case of a word output, the results of the
template evaluation must be words, and they are concatenated with WORD.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by
[C D E]. If multiple parallel slots are used, then (?REST 1) goes with
?1, etc.

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.

*Note WORD:: .


File: ucblogo.info,  Node: MAPdSE,  Next: FILTER,  Prev: MAP,  Up: TEMPLATE-BASED ITERATION

map.se
------

     MAP.SE template data				(library procedure)
     (MAP.SE template data1 data2 ...)

outputs a list formed by evaluating the template list repeatedly and
concatenating the results using SENTENCE.  That is, the members of the
output are the members of the results of the evaluations.  The output
list might, therefore, be of a different length from that of the data
input(s).  (If the result of an evaluation is the empty list, it
contributes nothing to the final output.)  The data inputs may be words
or lists.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by
[C D E]. If multiple parallel slots are used, then (?REST 1) goes with
?1, etc.

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.

*Note SENTENCE:: .


File: ucblogo.info,  Node: FILTER,  Next: FIND,  Prev: MAPdSE,  Up: TEMPLATE-BASED ITERATION

filter
------

     FILTER tftemplate data				(library procedure)

outputs a word or list, depending on the type of the data input,
containing a subset of the members (for a list) or characters (for a
word) of the input.  The template is evaluated once for each member or
character of the data, and it must produce a TRUE or FALSE value.  If
the value is TRUE, then the corresponding input constituent is included
in the output.

     ? print filter "vowelp "elephant
     eea
     ?

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by [C D E].

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.


File: ucblogo.info,  Node: FIND,  Next: REDUCE,  Prev: FILTER,  Up: TEMPLATE-BASED ITERATION

find
----

     FIND tftemplate data				(library procedure)

outputs the first constituent of the data input (the first member of a
list, or the first character of a word) for which the value produced by
evaluating the template with that consituent in its slot is TRUE.  If
there is no such constituent, the empty list is output.

In a template, the symbol ?REST represents the portion of the data input
to the right of the member currently being used as the ? slot-filler.
That is, if the data input is [A B C D E] and the template is being
evaluated with ? replaced by B, then ?REST would be replaced by [C D E].

In a template, the symbol # represents the position in the data input of
the member currently being used as the ? slot-filler.  That is, if the
data input is [A B C D E] and the template is being evaluated with ?
replaced by B, then # would be replaced by 2.


File: ucblogo.info,  Node: REDUCE,  Next: CROSSMAP,  Prev: FIND,  Up: TEMPLATE-BASED ITERATION

reduce
------

     REDUCE template data				(library procedure)

outputs the result of applying the template to accumulate the members of
the data input.  The template must be a two-slot function.  Typically it
is an associative function name like "SUM.  If the data input has only
one constituent (member in a list or character in a word), the output is
that consituent.  Otherwise, the template is first applied with ?1
filled with the next-to-last consitient and ?2 with the last
constituent.  Then, if there are more constituents, the template is
applied with ?1 filled with the next constituent to the left and ?2 with
the result from the previous evaluation.  This process continues until
all constituents have been used.  The data input may not be empty.

Note: If the template is, like SUM, the name of a procedure that is
capable of accepting arbitrarily many inputs, it is more efficient to
use APPLY instead of REDUCE.  The latter is good for associative
procedures that have been written to accept exactly two inputs:

     to max :a :b
     output ifelse :a > :b [:a] [:b]
     end

     print reduce "max [...]

Alternatively, REDUCE can be used to write MAX as a procedure that
accepts any number of inputs, as SUM does:

     to max [:inputs] 2
     if emptyp :inputs ~
        [(throw "error [not enough inputs to max])]
     output reduce [ifelse ?1 > ?2 [?1] [?2]] :inputs
     end

*Note SUM:: , *Note APPLY:: .


File: ucblogo.info,  Node: CROSSMAP,  Next: CASCADE,  Prev: REDUCE,  Up: TEMPLATE-BASED ITERATION

crossmap
--------

     CROSSMAP template listlist			(library procedure)
     (CROSSMAP template data1 data2 ...)

outputs a list containing the results of template evaluations.  Each
data list contributes to a slot in the template; the number of slots is
equal to the number of data list inputs.  As a special case, if only one
data list input is given, that list is taken as a list of data lists,
and each of its members contributes values to a slot.  CROSSMAP differs
from MAP in that instead of taking members from the data inputs in
parallel, it takes all possible combinations of members of data inputs,
which need not be the same length.

     ? show (crossmap [word ?1 ?2] [a b c] [1 2 3 4])
     [a1 a2 a3 a4 b1 b2 b3 b4 c1 c2 c3 c4]
     ?

For compatibility with the version in the first edition of CSLS (1),
CROSSMAP templates may use the notation :1 instead of ?1 to indicate
slots.

*Note MAP:: .

---------- Footnotes ----------

(1) Computer Science Logo Style


File: ucblogo.info,  Node: CASCADE,  Next: CASCADEd2,  Prev: CROSSMAP,  Up: TEMPLATE-BASED ITERATION

cascade
-------

     CASCADE endtest template startvalue		(library procedure)
     (CASCADE endtest tmp1 sv1 tmp2 sv2 ...)
     (CASCADE endtest tmp1 sv1 tmp2 sv2 ... finaltemplate)

outputs the result of applying a template (or several templates, as
explained below) repeatedly, with a given value filling the slot the
first time, and the result of each application filling the slot for the
following application.

In the simplest case, CASCADE has three inputs.  The second input is a
one-slot expression template.  That template is evaluated some number of
times (perhaps zero).  On the first evaluation, the slot is filled with
the third input; on subsequent evaluations, the slot is filled with the
result of the previous evaluation.  The number of evaluations is
determined by the first input.  This can be either a nonnegative
integer, in which case the template is evaluated that many times, or a
predicate expression template, in which case it is evaluated (with the
same slot filler that will be used for the evaluation of the second
input) repeatedly, and the CASCADE evaluation continues as long as the
predicate value is FALSE.  (In other words, the predicate template
indicates the condition for stopping.)

If the template is evaluated zero times, the output from CASCADE is the
third (startvalue) input.  Otherwise, the output is the value produced
by the last template evaluation.

CASCADE templates may include the symbol # to represent the number of
times the template has been evaluated.  This slot is filled with 1 for
the first evaluation, 2 for the second, and so on.

     ? show cascade 5 [lput # ?] []
     [1 2 3 4 5]
     ? show cascade [vowelp first ?] [bf ?] "spring
     ing
     ? show cascade 5 [# * ?] 1
     120
     ?

Several cascaded results can be computed in parallel by providing
additional template-startvalue pairs as inputs to CASCADE.  In this
case, all templates (including the endtest template, if used) are
multi-slot, with the number of slots equal to the number of pairs of
inputs.  In each round of evaluations, ?2 represents the result of
evaluating the second template in the previous round.  If the total
number of inputs (including the first endtest input) is odd, then the
output from CASCADE is the final value of the first template.  If the
total number of inputs is even, then the last input is a template that
is evaluated once, after the end test is satisfied, to determine the
output from CASCADE.

     to fibonacci :n
     output (cascade :n [?1 + ?2] 1 [?1] 0)
     end
     
     to piglatin :word
     output (cascade [vowelp first ?] ~
        [word bf ? first ?] ~
        :word ~
        [word ? "ay])
     end


File: ucblogo.info,  Node: CASCADEd2,  Next: TRANSFER,  Prev: CASCADE,  Up: TEMPLATE-BASED ITERATION

cascade.2
---------

     CASCADE.2 endtest temp1 startval1 temp2 startval2  (library procedure)

outputs the result of invoking CASCADE with the same inputs.  The only
difference is that the default number of inputs is five instead of
three.


File: ucblogo.info,  Node: TRANSFER,  Prev: CASCADEd2,  Up: TEMPLATE-BASED ITERATION

transfer
--------

     TRANSFER endtest template inbasket		(library procedure)

outputs the result of repeated evaluation of the template.  The template
is evaluated once for each member of the list `inbasket.'  TRANSFER
maintains an `outbasket' that is initially the empty list.  After each
evaluation of the template, the resulting value becomes the new
outbasket.

In the template, the symbol ?IN represents the current member from the
inbasket; the symbol ?OUT represents the entire current outbasket.
Other slot symbols should not be used.

If the first (endtest) input is an empty list, evaluation continues
until all inbasket members have been used.  If not, the first input must
be a predicate expression template, and evaluation continues until
either that template's value is TRUE or the inbasket is used up.


File: ucblogo.info,  Node: MACROS,  Next: ERROR PROCESSING,  Prev: CONTROL STRUCTURES,  Up: Top

Macros
******

* Menu:

* dMACRO::                      MACRO
* dDEFMACRO::                   DEFMACRO
* MACROP::
* MACROEXPAND::


File: ucblogo.info,  Node: dMACRO,  Next: dDEFMACRO,  Prev: MACROS,  Up: MACROS

.macro
------

     .MACRO procname :input1 :input2 ...			(special form)
     .DEFMACRO procname text

A macro is a special kind of procedure whose output is evaluated as Logo
instructions in the context of the macro's caller.  .MACRO is exactly
like TO except that the new procedure becomes a macro; .DEFMACRO is
exactly like DEFINE with the same exception.

Macros are useful for inventing new control structures comparable to
REPEAT, IF, and so on.  Such control structures can almost, but not
quite, be duplicated by ordinary Logo procedures.  For example, here is
an ordinary procedure version of REPEAT:

     to my.repeat :num :instructions
     if :num=0 [stop]
     run :instructions
     my.repeat :num-1 :instructions
     end

This version works fine for most purposes, e.g.,

     my.repeat 5 [print "hello]

But it doesn't work if the instructions to be carried out include
OUTPUT, STOP, or LOCAL.  For example, consider this procedure:

     to example
     print [Guess my secret word.  You get three guesses.]
     repeat 3 [type "|?? | ~
        if readword = "secret [pr "Right! stop]]
     print [Sorry, the word was "secret"!]
     end

This procedure works as written, but if MY.REPEAT is used instead of
REPEAT, it won't work because the STOP will stop MY.REPEAT instead of
stopping EXAMPLE as desired.

The solution is to make MY.REPEAT a macro.  Instead of actually carrying
out the computation, a macro must return a list containing Logo
instructions.  The contents of that list are evaluated as if they
appeared in place of the call to the macro.  Here's a macro version of
REPEAT:

     .macro my.repeat :num :instructions
     if :num=0 [output []]
     output sentence :instructions ~
        (list "my.repeat :num-1 :instructions)
     end

Every macro is an operation -- it must always output something.  Even in
the base case, MY.REPEAT outputs an empty instruction list.  To show how
MY.REPEAT works, let's take the example

     my.repeat 5 [print "hello]

For this example, MY.REPEAT will output the instruction list

     		[print "hello my.repeat 4 [print "hello]]

Logo then executes these instructions in place of the original
invocation of MY.REPEAT; this prints `hello' once and invokes another
repetition.

The technique just shown, although fairly easy to understand, has the
defect of slowness because each repetition has to construct an
instruction list for evaluation.  Another approach is to make my.repeat
a macro that works just like the non-macro version unless the
instructions to be repeated include OUTPUT or STOP:

     .macro my.repeat :num :instructions
     catch "repeat.catchtag ~
        [op repeat.done runresult [repeat1 :num :instructions]]
     op []
     end
     
     to repeat1 :num :instructions
     if :num=0 [throw "repeat.catchtag]
     run :instructions
     .maybeoutput repeat1 :num-1 :instructions
     end
     
     to repeat.done :repeat.result
     if emptyp :repeat.result [op [stop]]
     op list "output quoted first :repeat.result
     end

If the instructions do not include STOP or OUTPUT, then REPEAT1 will
reach its base case and invoke THROW.  As a result, my.repeat's last
instruction line will output an empty list, so the second evaluation of
the macro result will do nothing.  But if a STOP or OUTPUT happens, then
REPEAT.DONE will output a STOP or OUTPUT instruction that will be
re-executed in the caller's context.

The macro-defining commands have names starting with a dot because
macros are an advanced feature of Logo; it's easy to get in trouble by
defining a macro that doesn't terminate, or by failing to construct the
instruction list properly.

Lisp users should note that Logo macros are NOT special forms.  That is,
the inputs to the macro are evaluated normally, as they would be for any
other Logo procedure.  It's only the output from the macro that's
handled unusually.

Here's another example:

     .macro localmake :name :value
     output (list "local~
        word "" :name   ~
        "apply          ~
        ""make          ~
        (list :name :value))
     end

It's used this way:

     to try
     localmake "garply "hello
     print :garply
     end

LOCALMAKE outputs the list

     		[local "garply apply "make [garply hello]]

The reason for the use of APPLY is to avoid having to decide whether or
not the second input to MAKE requires a quotation mark before it.  (In
this case it would -- MAKE "GARPLY "HELLO -- but the quotation mark
would be wrong if the value were a list.)

It's often convenient to use the ` function to construct the instruction
list:

     .macro localmake :name :value
     op `[local ,[word "" :name] apply "make [,[:name] ,[:value]]]
     end

On the other hand, ` is pretty slow, since it's tree recursive and
written in Logo.

*Note TO:: , *Note DEFINE:: , *Note APPLY:: , *Note STOP:: , *Note
OUTPUT:: .


File: ucblogo.info,  Node: dDEFMACRO,  Next: MACROP,  Prev: dMACRO,  Up: MACROS

.defmacro
---------

*Note dMACRO:: .


File: ucblogo.info,  Node: MACROP,  Next: MACROEXPAND,  Prev: dDEFMACRO,  Up: MACROS

macrop
------

     MACROP name
     MACRO? name

outputs TRUE if its input is the name of a macro.


File: ucblogo.info,  Node: MACROEXPAND,  Prev: MACROP,  Up: MACROS

macroexpand
-----------

     MACROEXPAND expr				(library procedure)

takes as its input a Logo expression that invokes a macro (that is, one
that begins with the name of a macro) and outputs the the Logo
expression into which the macro would translate the input expression.

     .macro localmake :name :value
     op `[local ,[word "" :name] apply "make [,[:name] ,[:value]]]
     end
     
     ? show macroexpand [localmake "pi 3.14159]
     [local "pi apply "make [pi 3.14159]]


File: ucblogo.info,  Node: ERROR PROCESSING,  Next: SPECIAL VARIABLES,  Prev: MACROS,  Up: Top

Error Processing
****************

* Menu:

* ERROR CODES::

If an error occurs, Logo takes the following steps.  First, if there is
an available variable named ERRACT, Logo takes its value as an
instructionlist and runs the instructions.  The operation ERROR may be
used within the instructions (once) to examine the error condition.  If
the instructionlist invokes PAUSE, the error message is printed before
the pause happens.  Certain errors are "recoverable"; for one of those
errors, if the instructionlist outputs a value, that value is used in
place of the expression that caused the error.  (If ERRACT invokes
PAUSE and the user then invokes CONTINUE with an input, that input
becomes the output from PAUSE and therefore the output from the ERRACT
instructionlist.)

It is possible for an ERRACT instructionlist to produce an
inappropriate value or no value where one is needed.  As a result, the
same error condition could recur forever because of this mechanism.  To
avoid that danger, if the same error condition occurs twice in a row
from an ERRACT instructionlist without user interaction, the message
"Erract loop" is printed and control returns to toplevel.  "Without
user interaction" means that if ERRACT invokes PAUSE and the user
provides an incorrect value, this loop prevention mechanism does not
take effect and the user gets to try again.

During the running of the ERRACT instructionlist, ERRACT is locally
unbound, so an error in the ERRACT instructions themselves will not
cause a loop.  In particular, an error during a pause will not cause a
pause-within-a-pause unless the user reassigns the value [PAUSE] to
ERRACT during the pause.  But such an error will not return to
toplevel; it will remain within the original pause loop.

If there is no available ERRACT value, Logo handles the error by
generating an internal THROW "ERROR.  (A user program can also generate
an error condition deliberately by invoking THROW.)  If this throw is
not caught by a CATCH "ERROR in the user program, it is eventually
caught either by the toplevel instruction loop or by a pause loop,
which prints the error message. An invocation of CATCH "ERROR in a user
program locally unbinds ERRACT, so the effect is that whichever of
ERRACT and CATCH "ERROR is more local will take precedence.

If a floating point overflow occurs during an arithmetic operation, or a
two-input mathematical function (like POWER) is invoked with an illegal
combination of inputs, the `doesn't like' message refers to the second
operand, but should be taken as meaning the combination.

*Note ERRACT:: , *Note THROW:: , *Note ERROR:: , *Note CATCH:: , *Note
PAUSE:: , *Note CONTINUE:: .


File: ucblogo.info,  Node: ERROR CODES,  Prev: ERROR PROCESSING,  Up: ERROR PROCESSING

Error Codes
===========

Here are the numeric codes that appear as the first member of the list
output by ERROR when an error is caught, with the corresponding
messages.  Some messages may have two different codes depending on
whether or not the error is recoverable (that is, a substitute value
can be provided through the ERRACT mechanism) in the specific context.
Some messages are warnings rather than errors; these will not be
caught.  Errors 0 and 32 are so bad that Logo exits immediately.


       0	Fatal internal error (can't be caught)
       1	Out of memory
       2	Stack overflow
       3	Turtle out of bounds
       4	PROC doesn't like DATUM as input (not recoverable)
       5	PROC didn't output to PROC
       6	Not enough inputs to PROC
       7	PROC doesn't like DATUM as input (recoverable)
       8	Too much inside ()'s
       9 	You don't say what to do with DATUM
      10	')' not found
      11	VAR has no value
      12	Unexpected ')'
      13	I don't know how to PROC (recoverable)
      14	Can't find catch tag for THROWTAG
      15	PROC is already defined
      16	Stopped
      17	Already dribbling
      18	File system error
      19	Assuming you mean IFELSE, not IF (warning only)
      20	VAR shadowed by local in procedure call (warning only)
      21	Throw "Error
      22	PROC is a primitive
      23	Can't use TO inside a procedure
      24	I don't know how to PROC (not recoverable)
      25	IFTRUE/IFFALSE without TEST
      26	Unexpected ']'
      27	Unexpected '}'
      28	Couldn't initialize graphics
      29	Macro returned VALUE instead of a list
      30	You don't say what to do with VALUE
      31	Can only use STOP or OUTPUT inside a procedure
      32	APPLY doesn't like BADTHING as input
      33	END inside multi-line instruction
      34	Really out of memory (can't be caught)


File: ucblogo.info,  Node: SPECIAL VARIABLES,  Next: INDEX,  Prev: ERROR PROCESSING,  Up: Top

Special Variables
*****************

Logo takes special action if any of the following variable names exists.
They follow the normal scoping rules, so a procedure can locally set one
of them to limit the scope of its effect.  Initially, no variables exist
except ALLOWGETSET, CASEIGNOREDP, and UNBURYONEDIT, which is TRUE and
buried.

* Menu:

* ALLOWGETSET::
* CASEIGNOREDP::
* ERRACT::
* FULLPRINTP::
* LOADNOISILY::
* PRINTDEPTHLIMIT::
* PRINTWIDTHLIMIT::
* REDEFP::
* STARTUP::
* UNBURYONEDIT::


File: ucblogo.info,  Node: ALLOWGETSET,  Next: CASEIGNOREDP,  Prev: SPECIAL VARIABLES,  Up: SPECIAL VARIABLES

allowgetset
-----------

     ALLOWGETSET                           (variable)

if TRUE, indicates that an attempt to use a procedure that doesn't exist
should be taken as an implicit getter or setter procedure (setter if the
first three letters of the name are SET) for a variable of the same name
(without the SET if appropriate).


File: ucblogo.info,  Node: CASEIGNOREDP,  Next: ERRACT,  Prev: ALLOWGETSET,  Up: SPECIAL VARIABLES

caseignoredp
------------

     CASEIGNOREDP                                (variable)

if TRUE, indicates that lower case and upper case letters should be
considered equal by EQUALP, BEFOREP, MEMBERP, etc.  Logo initially makes
this variable TRUE, and buries it.

*Note EQUALP:: , *Note BEFOREP:: , *Note MEMBERP:: .


File: ucblogo.info,  Node: ERRACT,  Next: FULLPRINTP,  Prev: CASEIGNOREDP,  Up: SPECIAL VARIABLES

erract
------

     ERRACT                                      (variable)

an instructionlist that will be run in the event of an error.  Typically
has the value [PAUSE] to allow interactive debugging.

*Note PAUSE:: .


File: ucblogo.info,  Node: FULLPRINTP,  Next: LOADNOISILY,  Prev: ERRACT,  Up: SPECIAL VARIABLES

fullprintp
----------

     FULLPRINTP

if TRUE, then words that were created using backslash or vertical bar
(to include characters that would otherwise not be treated as part of a
word) are printed with the backslashes or vertical bars shown, so that
the printed result could be re-read by Logo to produce the same value.
If FULLPRINTP is TRUE then the empty word (however it was created)
prints as `||'.  (Otherwise it prints as nothing at all.)


File: ucblogo.info,  Node: LOADNOISILY,  Next: PRINTDEPTHLIMIT,  Prev: FULLPRINTP,  Up: SPECIAL VARIABLES

loadnoisily
-----------

     LOADNOISILY                                 (variable)

if TRUE, prints the names of procedures defined when loading from a file
(including the temporary file made by EDIT).

*Note EDIT:: .


File: ucblogo.info,  Node: PRINTDEPTHLIMIT,  Next: PRINTWIDTHLIMIT,  Prev: LOADNOISILY,  Up: SPECIAL VARIABLES

printdepthlimit
---------------

     PRINTDEPTHLIMIT                             (variable)

if a nonnegative integer, indicates the maximum depth of sublist
structure that will be printed by PRINT, etc.

*Note PRINT:: .


File: ucblogo.info,  Node: PRINTWIDTHLIMIT,  Next: REDEFP,  Prev: PRINTDEPTHLIMIT,  Up: SPECIAL VARIABLES

printwidthlimit
---------------

     PRINTWIDTHLIMIT                             (variable)

if a nonnegative integer, indicates the maximum number of members in any
one list that will be printed by PRINT, etc.

*Note PRINT:: .


File: ucblogo.info,  Node: REDEFP,  Next: STARTUP,  Prev: PRINTWIDTHLIMIT,  Up: SPECIAL VARIABLES

redefp
------

     REDEFP                                      (variable)

if TRUE, allows primitives to be erased (ERASE) or redefined (COPYDEF).

*Note ERASE:: , *Note COPYDEF:: .


File: ucblogo.info,  Node: STARTUP,  Next: UNBURYONEDIT,  Prev: REDEFP,  Up: SPECIAL VARIABLES

startup
-------

     STARTUP                                     (variable)

if assigned a list value in a file loaded by LOAD, that value is run as
an instructionlist after the loading.

*Note LOAD:: .


File: ucblogo.info,  Node: UNBURYONEDIT,  Prev: STARTUP,  Up: SPECIAL VARIABLES

unburyonedit
------------

     UNBURYONEDIT                            (variable)

if TRUE, causes any procedure defined during EDIT or LOAD to be
unburied, so that it will be saved by a later SAVE.  Files that want to
define and bury procedures must do it in that order.

*Note EDIT:: , *Note LOAD:: , *Note SAVE:: .


File: ucblogo.info,  Node: INDEX,  Prev: SPECIAL VARIABLES,  Up: Top

INDEX
*****

* Menu:

* *:                                     PRODUCT.
* +:                                     SUM.
* -:                                     DIFFERENCE.
* .defmacro:                             dMACRO.
* .eq:                                   dEQ.
* .macro:                                dMACRO.
* .maybeoutput:                          dMAYBEOUTPUT.
* .setbf:                                dSETBF.
* .setfirst:                             dSETFIRST.
* .setitem:                              dSETITEM.
* /:                                     QUOTIENT.
* <:                                     LESSP.
* =:                                     EQUALP.
* >:                                     GREATERP.
* `:                                     back-quote.
* allopen:                               ALLOPEN.
* allowgetset:                           ALLOWGETSET.
* AllowGetterSetter:                     GETTER/SETTER VARIBLE SYNTAX.
* and:                                   AND.
* apply:                                 APPLY.
* arc:                                   ARC.
* arctan:                                ARCTAN.
* array:                                 ARRAY.
* array?:                                ARRAYP.
* arrayp:                                ARRAYP.
* arraytolist:                           ARRAYTOLIST.
* ascii:                                 ASCII.
* ashift:                                ASHIFT.
* back:                                  BACK.
* background:                            BACKGROUND.
* backslashed?:                          BACKSLASHEDP.
* backslashedp:                          BACKSLASHEDP.
* before?:                               BEFOREP.
* beforep:                               BEFOREP.
* bf:                                    BUTFIRST.
* bfs:                                   BUTFIRSTS.
* bg:                                    BACKGROUND.
* bitand:                                BITAND.
* bitnot:                                BITNOT.
* bitor:                                 BITOR.
* bitxor:                                BITXOR.
* bk:                                    BACK.
* bl:                                    BUTLAST.
* buried:                                BURIED.
* buried?:                               BURIEDP.
* buriedp:                               BURIEDP.
* bury:                                  BURY.
* buryall:                               BURYALL.
* buryname:                              BURYNAME.
* butfirst:                              BUTFIRST.
* butfirsts:                             BUTFIRSTS.
* butlast:                               BUTLAST.
* bye:                                   BYE.
* cascade:                               CASCADE.
* cascade.2:                             CASCADEd2.
* case-insensitive:                      TOKENIZATION.
* caseignoredp:                          CASEIGNOREDP.
* catch:                                 CATCH.
* char:                                  CHAR.
* clean:                                 CLEAN.
* clearscreen:                           CLEARSCREEN.
* cleartext:                             CLEARTEXT.
* close:                                 CLOSE.
* closeall:                              CLOSEALL.
* co:                                    CONTINUE.
* combine:                               COMBINE.
* comments:                              TOKENIZATION.
* Computer_Science_Logo_Style:           OVERVIEW.
* contents:                              CONTENTS.
* continue:                              CONTINUE.
* copydef:                               COPYDEF.
* Copyright:                             OVERVIEW.
* cos:                                   COS.
* count:                                 COUNT.
* crossmap:                              CROSSMAP.
* cs:                                    CLEARSCREEN.
* ct:                                    CLEARTEXT.
* cursor:                                CURSOR.
* define:                                DEFINE.
* defined?:                              DEFINEDP.
* definedp:                              DEFINEDP.
* delimiters:                            TOKENIZATION.
* dequeue:                               DEQUEUE.
* difference:                            DIFFERENCE.
* do.until:                              DOdUNTIL.
* do.while:                              DOdWHILE.
* dribble:                               DRIBBLE.
* ed:                                    EDIT.
* edall:                                 EDALL.
* edit:                                  EDIT.
* editfile:                              EDITFILE.
* editor:                                EDIT.
* edn:                                   EDN.
* edns:                                  EDNS.
* edpl:                                  EDPL.
* edpls:                                 EDPLS.
* edps:                                  EDPS.
* empty?:                                EMPTYP.
* emptyp:                                EMPTYP.
* eof?:                                  EOFP.
* eofp:                                  EOFP.
* epspict:                               EPSPICT.
* equal?:                                EQUALP.
* equalp:                                EQUALP.
* er:                                    ERASE.
* erall:                                 ERALL.
* erase:                                 ERASE.
* erasefile:                             ERASEFILE.
* erf:                                   ERASEFILE.
* ern:                                   ERN.
* erns:                                  ERNS.
* erpl:                                  ERPL.
* erpls:                                 ERPLS.
* erps:                                  ERPS.
* erract:                                ERRACT.
* error:                                 ERROR.
* errors:                                ERROR CODES.
* exp:                                   EXP.
* fd:                                    FORWARD.
* fence:                                 FENCE.
* file?:                                 FILEP.
* filep:                                 FILEP.
* fill:                                  FILL.
* filter:                                FILTER.
* find:                                  FIND.
* first:                                 FIRST.
* firsts:                                FIRSTS.
* for:                                   FOR.
* foreach:                               FOREACH.
* forever:                               FOREVER.
* form:                                  FORM.
* forward:                               FORWARD.
* fput:                                  FPUT.
* fs:                                    FULLSCREEN.
* fullprintp:                            FULLPRINTP.
* fullscreen:                            FULLSCREEN.
* fulltext:                              FULLTEXT.
* gc:                                    GC.
* gensym:                                GENSYM.
* getter:                                GETTER/SETTER VARIBLE SYNTAX.
* goto:                                  GOTO.
* gprop:                                 GPROP.
* greater?:                              GREATERP.
* greaterp:                              GREATERP.
* heading:                               HEADING.
* help:                                  HELP.
* hideturtle:                            HIDETURTLE.
* home:                                  HOME.
* ht:                                    HIDETURTLE.
* if:                                    IF.
* ifelse:                                IFELSE.
* iff:                                   IFFALSE.
* iffalse:                               IFFALSE.
* ift:                                   IFTRUE.
* iftrue:                                IFTRUE.
* ignore:                                IGNORE.
* int:                                   INT.
* invoke:                                INVOKE.
* iseq:                                  ISEQ.
* item:                                  ITEM.
* key?:                                  KEYP.
* keyp:                                  KEYP.
* label:                                 LABEL.
* last:                                  LAST.
* leaving ucblogo:                       ENTERING AND LEAVING LOGO.
* left:                                  LEFT.
* less?:                                 LESSP.
* lessp:                                 LESSP.
* line-continuation:                     TOKENIZATION.
* list:                                  LIST.
* list?:                                 LISTP.
* listp:                                 LISTP.
* listtoarray:                           LISTTOARRAY.
* ln:                                    LN.
* load:                                  LOAD.
* loadnoisily:                           LOADNOISILY.
* loadpict:                              LOADPICT.
* local:                                 LOCAL.
* localmake:                             LOCALMAKE.
* log10:                                 LOG10.
* logohelp:                              HELP.
* lowercase:                             LOWERCASE.
* lput:                                  LPUT.
* lshift:                                LSHIFT.
* lt:                                    LEFT.
* macro?:                                MACROP.
* macroexpand:                           MACROEXPAND.
* macrop:                                MACROP.
* make:                                  MAKE.
* map:                                   MAP.
* map.se:                                MAPdSE.
* mdarray:                               MDARRAY.
* mditem:                                MDITEM.
* mdsetitem:                             MDSETITEM.
* member:                                MEMBER.
* member?:                               MEMBERP.
* memberp:                               MEMBERP.
* minus:                                 MINUS.
* modulo:                                MODULO.
* name:                                  NAME.
* name?:                                 NAMEP.
* namelist:                              NAMELIST.
* namep:                                 NAMEP.
* names:                                 NAMES.
* nodes:                                 NODES.
* nodribble:                             NODRIBBLE.
* norefresh:                             NOREFRESH.
* not:                                   NOT.
* number?:                               NUMBERP.
* numberp:                               NUMBERP.
* op:                                    OUTPUT.
* openappend:                            OPENAPPEND.
* openread:                              OPENREAD.
* openupdate:                            OPENUPDATE.
* openwrite:                             OPENWRITE.
* or:                                    OR.
* output:                                OUTPUT.
* palette:                               PALETTE.
* parse:                                 PARSE.
* pause:                                 PAUSE.
* pc:                                    PENCOLOR.
* pd:                                    PENDOWN.
* pe:                                    PENERASE.
* pen:                                   PEN.
* pencolor:                              PENCOLOR.
* pendown:                               PENDOWN.
* pendown?:                              PENDOWNP.
* pendownp:                              PENDOWNP.
* penerase:                              PENERASE.
* penmode:                               PENMODE.
* penpaint:                              PENPAINT.
* penpattern:                            PENSIZE.
* penreverse:                            PENREVERSE.
* pensize:                               PENSIZE.
* penup:                                 PENUP.
* pick:                                  PICK.
* plist:                                 PLIST.
* plist?:                                PLISTP.
* plistp:                                PLISTP.
* plists:                                PLISTS.
* pllist:                                PLLIST.
* po:                                    PO.
* poall:                                 POALL.
* pon:                                   PON.
* pons:                                  PONS.
* pop:                                   POP.
* popl:                                  POPL.
* popls:                                 POPLS.
* pops:                                  POPS.
* pos:                                   POS.
* pot:                                   POT.
* pots:                                  POTS.
* power:                                 POWER.
* pprop:                                 PPROP.
* ppt:                                   PENPAINT.
* pr:                                    PRINT.
* prefix:                                PREFIX.
* primitive?:                            PRIMITIVEP.
* primitivep:                            PRIMITIVEP.
* print:                                 PRINT.
* printdepthlimit:                       PRINTDEPTHLIMIT.
* printwidthlimit:                       PRINTWIDTHLIMIT.
* procedure?:                            PROCEDUREP.
* procedurep:                            PROCEDUREP.
* procedures:                            PROCEDURES.
* product:                               PRODUCT.
* pu:                                    PENUP.
* push:                                  PUSH.
* px:                                    PENREVERSE.
* queue:                                 QUEUE.
* quoted:                                QUOTED.
* quotient:                              QUOTIENT.
* radarctan:                             RADARCTAN.
* radcos:                                RADCOS.
* radsin:                                RADSIN.
* random:                                RANDOM.
* rawascii:                              RAWASCII.
* rc:                                    READCHAR.
* rcs:                                   READCHARS.
* readchar:                              READCHAR.
* readchars:                             READCHARS.
* reader:                                READER.
* readlist:                              READLIST.
* readpos:                               READPOS.
* readrawline:                           READRAWLINE.
* readword:                              READWORD.
* redefp:                                REDEFP.
* reduce:                                REDUCE.
* refresh:                               REFRESH.
* remainder:                             REMAINDER.
* remdup:                                REMDUP.
* remove:                                REMOVE.
* remprop:                               REMPROP.
* repcount:                              REPCOUNT.
* repeat:                                REPEAT.
* rerandom:                              RERANDOM.
* reverse:                               REVERSE.
* right:                                 RIGHT.
* rl:                                    READLIST.
* round:                                 ROUND.
* rseq:                                  RSEQ.
* rt:                                    RIGHT.
* run:                                   RUN.
* runparse:                              RUNPARSE.
* runparsing:                            TOKENIZATION.
* runresult:                             RUNRESULT.
* rw:                                    READWORD.
* save:                                  SAVE.
* savel:                                 SAVEL.
* savepict:                              SAVEPICT.
* scrunch:                               SCRUNCH.
* scrunch.dat:                           SETSCRUNCH.
* se:                                    SENTENCE.
* sentence:                              SENTENCE.
* setbackground:                         SETBACKGROUND.
* setbg:                                 SETBACKGROUND.
* setcursor:                             SETCURSOR.
* seth:                                  SETHEADING.
* setheading:                            SETHEADING.
* setitem:                               SETITEM.
* setmargins:                            SETMARGINS.
* setpalette:                            SETPALETTE.
* setpc:                                 SETPENCOLOR.
* setpen:                                SETPEN.
* setpencolor:                           SETPENCOLOR.
* setpenpattern:                         SETPENPATTERN.
* setpensize:                            SETPENSIZE.
* setpos:                                SETPOS.
* setprefix:                             SETPREFIX.
* setread:                               SETREAD.
* setreadpos:                            SETREADPOS.
* setscrunch:                            SETSCRUNCH.
* settc:                                 SETTEXTCOLOR.
* setter:                                GETTER/SETTER VARIBLE SYNTAX.
* settextcolor:                          SETTEXTCOLOR.
* setwrite:                              SETWRITE.
* setwritepos:                           SETWRITEPOS.
* setx:                                  SETX.
* setxy:                                 SETXY.
* sety:                                  SETY.
* shell:                                 SHELL.
* show:                                  SHOW.
* shown?:                                SHOWNP.
* shownp:                                SHOWNP.
* showturtle:                            SHOWTURTLE.
* sin:                                   SIN.
* splitscreen:                           SPLITSCREEN.
* sqrt:                                  SQRT.
* ss:                                    SPLITSCREEN.
* st:                                    SHOWTURTLE.
* standout:                              STANDOUT.
* starting ucblogo:                      ENTERING AND LEAVING LOGO.
* startup:                               STARTUP.
* step:                                  STEP.
* stepped:                               STEPPED.
* stepped?:                              STEPPEDP.
* steppedp:                              STEPPEDP.
* stop:                                  STOP.
* substring?:                            SUBSTRINGP.
* substringp:                            SUBSTRINGP.
* sum:                                   SUM.
* tag:                                   TAG.
* temp:                                  EDIT.
* template:                              TEMPLATE-BASED ITERATION.
* test:                                  TEST.
* text:                                  TEXT.
* textscreen:                            TEXTSCREEN.
* thing:                                 THING.
* throw:                                 THROW.
* to:                                    TO.
* towards:                               TOWARDS.
* trace:                                 TRACE.
* traced:                                TRACED.
* traced?:                               TRACEDP.
* tracedp:                               TRACEDP.
* transfer:                              TRANSFER.
* ts:                                    TEXTSCREEN.
* type:                                  TYPE.
* unbury:                                UNBURY.
* unburyall:                             UNBURYALL.
* unburyname:                            UNBURYNAME.
* unburyonedit:                          UNBURYONEDIT.
* unstep:                                UNSTEP.
* until:                                 UNTIL.
* untrace:                               UNTRACE.
* uppercase:                             UPPERCASE.
* wait:                                  WAIT.
* while:                                 WHILE.
* window:                                WINDOW.
* word:                                  WORD.
* wordp:                                 WORDP.
* wrap:                                  WRAP.
* writepos:                              WRITEPOS.
* writer:                                WRITER.
* xcor:                                  XCOR.
* ycor:                                  YCOR.


